/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Red Matter
 * API configuration
 *
 * OpenAPI spec version: 1.0.0
 *
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://www.redmatterapp.com".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
  csv: ",",
  ssv: " ",
  tsv: "\t",
  pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
  (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
  url: string;
  options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
  protected configuration: Configuration;

  constructor(
    configuration?: Configuration,
    protected basePath: string = BASE_PATH,
    protected fetch: FetchAPI = portableFetch
  ) {
    if (configuration) {
      this.configuration = configuration;
      this.basePath = configuration.basePath || this.basePath;
    }
  }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
  name: "RequiredError";
  constructor(public field: string, msg?: string) {
    super(msg);
  }
}

/**
 *
 * @export
 * @interface Body
 */
export interface Body {
  /**
   *
   * @type {string}
   * @memberof Body
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof Body
   */
  password: string;
}
/**
 *
 * @export
 * @interface Body1
 */
export interface Body1 {
  /**
   *
   * @type {string}
   * @memberof Body1
   */
  location: string;
  /**
   *
   * @type {string}
   * @memberof Body1
   */
  organisation: string;
  /**
   *
   * @type {string}
   * @memberof Body1
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof Body1
   */
  password: string;
  /**
   *
   * @type {string}
   * @memberof Body1
   */
  gRecaptchaResponse: string;
}
/**
 *
 * @export
 * @interface Body2
 */
export interface Body2 {
  /**
   *
   * @type {string}
   * @memberof Body2
   */
  feedback?: string;
}
/**
 *
 * @export
 * @interface Body3
 */
export interface Body3 {
  /**
   * Organisation Id
   * @type {string}
   * @memberof Body3
   */
  organisationId?: string;
  /**
   * Name of workspace
   * @type {string}
   * @memberof Body3
   */
  name?: string;
  /**
   * private or public workspace
   * @type {boolean}
   * @memberof Body3
   */
  isPrivate?: boolean;
}
/**
 *
 * @export
 * @interface Body4
 */
export interface Body4 {
  /**
   *
   * @type {string}
   * @memberof Body4
   */
  workspaceId?: string;
  /**
   *
   * @type {string}
   * @memberof Body4
   */
  organisationId?: string;
  /**
   *
   * @type {Blob}
   * @memberof Body4
   */
  file0?: Blob;
}
/**
 *
 * @export
 * @interface Body5
 */
export interface Body5 {
  /**
   * Graph Name
   * @type {string}
   * @memberof Body5
   */
  graphName?: string;
  /**
   * Workspace Id
   * @type {string}
   * @memberof Body5
   */
  workspaceId?: string;
  /**
   * Send the updated graph object
   * @type {any}
   * @memberof Body5
   */
  graphChanges?: any;
}
/**
 *
 * @export
 * @interface Body6
 */
export interface Body6 {
  /**
   *
   * @type {string}
   * @memberof Body6
   */
  graphName?: string;
  /**
   *
   * @type {string}
   * @memberof Body6
   */
  workspaceId?: string;
}
/**
 *
 * @export
 * @interface ExperimentDetailView
 */
export interface ExperimentDetailView {
  /**
   *
   * @type {string}
   * @memberof ExperimentDetailView
   */
  device?: string;
  /**
   *
   * @type {string}
   * @memberof ExperimentDetailView
   */
  cellType?: string;
  /**
   *
   * @type {string}
   * @memberof ExperimentDetailView
   */
  particleSize?: string;
  /**
   *
   * @type {string}
   * @memberof ExperimentDetailView
   */
  fluorophoresCategory?: string;
  /**
   *
   * @type {string}
   * @memberof ExperimentDetailView
   */
  description?: string;
}
/**
 *
 * @export
 * @interface ExperimentPayload
 */
export interface ExperimentPayload {
  /**
   *
   * @type {ExperimentDetailView}
   * @memberof ExperimentPayload
   */
  details?: ExperimentDetailView;
  /**
   *
   * @type {any}
   * @memberof ExperimentPayload
   */
  data?: any;
  /**
   *
   * @type {string}
   * @memberof ExperimentPayload
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof ExperimentPayload
   */
  privateExp?: boolean;
}
/**
 *
 * @export
 * @interface GatingCoords
 */
export interface GatingCoords {
  /**
   *
   * @type {number}
   * @memberof GatingCoords
   */
  x?: number;
  /**
   *
   * @type {number}
   * @memberof GatingCoords
   */
  y?: number;
}
/**
 *
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse200
   */
  token?: string;
  /**
   *
   * @type {InlineResponse200UserDetails}
   * @memberof InlineResponse200
   */
  userDetails?: InlineResponse200UserDetails;
}
/**
 *
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse2001
   */
  message?: string;
}
/**
 *
 * @export
 * @interface InlineResponse20010
 */
export interface InlineResponse20010 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse20010
   */
  token?: string;
  /**
   *
   * @type {Array<any>}
   * @memberof InlineResponse20010
   */
  statistics?: Array<any>;
}
/**
 *
 * @export
 * @interface InlineResponse20011
 */
export interface InlineResponse20011 {
  /**
   *
   * @type {Array<any>}
   * @memberof InlineResponse20011
   */
  fileIds?: Array<any>;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20011
   */
  graphName?: string;
  /**
   *
   * @type {boolean}
   * @memberof InlineResponse20011
   */
  isDotPlot?: boolean;
  /**
   *
   * @type {number}
   * @memberof InlineResponse20011
   */
  paramX?: number;
  /**
   *
   * @type {number}
   * @memberof InlineResponse20011
   */
  paramY?: number;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20011
   */
  selectedGate?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20011
   */
  xScale?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20011
   */
  yScale?: string;
  /**
   *
   * @type {number}
   * @memberof InlineResponse20011
   */
  height?: number;
  /**
   *
   * @type {number}
   * @memberof InlineResponse20011
   */
  width?: number;
}
/**
 *
 * @export
 * @interface InlineResponse20012
 */
export interface InlineResponse20012 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse20012
   */
  gateName?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20012
   */
  token?: string;
}
/**
 *
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse2002
   */
  token?: string;
  /**
   *
   * @type {Array<InlineResponse2002Workspaces>}
   * @memberof InlineResponse2002
   */
  workspaces?: Array<InlineResponse2002Workspaces>;
}
/**
 *
 * @export
 * @interface InlineResponse2002Workspaces
 */
export interface InlineResponse2002Workspaces {
  /**
   * workspace id
   * @type {string}
   * @memberof InlineResponse2002Workspaces
   */
  id?: string;
  /**
   * workspace name
   * @type {string}
   * @memberof InlineResponse2002Workspaces
   */
  name?: string;
  /**
   * workspace created date
   * @type {string}
   * @memberof InlineResponse2002Workspaces
   */
  createdOn?: string;
  /**
   *
   * @type {boolean}
   * @memberof InlineResponse2002Workspaces
   */
  isOwner?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof InlineResponse2002Workspaces
   */
  isPrivate?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof InlineResponse2002Workspaces
   */
  noAccepted?: boolean;
  /**
   * Email of user
   * @type {string}
   * @memberof InlineResponse2002Workspaces
   */
  owner?: string;
}
/**
 *
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse2003
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse2003
   */
  location?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse2003
   */
  token?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse2003
   */
  organisationId?: string;
}
/**
 *
 * @export
 * @interface InlineResponse2004
 */
export interface InlineResponse2004 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse2004
   */
  token?: string;
  /**
   * Workspace id
   * @type {string}
   * @memberof InlineResponse2004
   */
  id?: string;
  /**
   * Workspace name
   * @type {string}
   * @memberof InlineResponse2004
   */
  name?: string;
  /**
   * Workspace creation date
   * @type {string}
   * @memberof InlineResponse2004
   */
  createdOn?: string;
}
/**
 *
 * @export
 * @interface InlineResponse2005
 */
export interface InlineResponse2005 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse2005
   */
  token?: string;
}
/**
 *
 * @export
 * @interface InlineResponse2006
 */
export interface InlineResponse2006 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse2006
   */
  token?: string;
  /**
   * experiment id
   * @type {string}
   * @memberof InlineResponse2006
   */
  id?: string;
  /**
   * experiment details
   * @type {any}
   * @memberof InlineResponse2006
   */
  details?: any;
  /**
   * experiment data
   * @type {string}
   * @memberof InlineResponse2006
   */
  data?: string;
}
/**
 *
 * @export
 * @interface InlineResponse2007
 */
export interface InlineResponse2007 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse2007
   */
  token?: string;
  /**
   * experiment id
   * @type {string}
   * @memberof InlineResponse2007
   */
  id?: string;
  /**
   *
   * @type {ExperimentDetailView}
   * @memberof InlineResponse2007
   */
  details?: ExperimentDetailView;
  /**
   * experiment data
   * @type {any}
   * @memberof InlineResponse2007
   */
  data?: any;
}
/**
 *
 * @export
 * @interface InlineResponse2008
 */
export interface InlineResponse2008 {
  /**
   * Name of workspace
   * @type {string}
   * @memberof InlineResponse2008
   */
  workspaceName?: string;
  /**
   * number of files remaining for user
   * @type {number}
   * @memberof InlineResponse2008
   */
  filesRemaining?: number;
  /**
   * Exp. Date of workspace
   * @type {string}
   * @memberof InlineResponse2008
   */
  availableUntil?: string;
  /**
   *
   * @type {number}
   * @memberof InlineResponse2008
   */
  monthlyFileCounter?: number;
  /**
   *
   * @type {boolean}
   * @memberof InlineResponse2008
   */
  isOwner?: boolean;
  /**
   *
   * @type {string}
   * @memberof InlineResponse2008
   */
  token?: string;
  /**
   *
   * @type {Array<InlineResponse2008Files>}
   * @memberof InlineResponse2008
   */
  files?: Array<InlineResponse2008Files>;
}
/**
 *
 * @export
 * @interface InlineResponse2008Files
 */
export interface InlineResponse2008Files {
  /**
   * Id of file
   * @type {string}
   * @memberof InlineResponse2008Files
   */
  id?: string;
  /**
   * Workspace Id
   * @type {string}
   * @memberof InlineResponse2008Files
   */
  workspaceId?: string;
  /**
   * Name of file
   * @type {string}
   * @memberof InlineResponse2008Files
   */
  label?: string;
  /**
   * Date of creation
   * @type {string}
   * @memberof InlineResponse2008Files
   */
  createdOn?: string;
}
/**
 *
 * @export
 * @interface InlineResponse2009
 */
export interface InlineResponse2009 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse2009
   */
  workspaceName?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse2009
   */
  version?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse2009
   */
  token?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse2009
   */
  path?: string;
  /**
   *
   * @type {number}
   * @memberof InlineResponse2009
   */
  numParams?: number;
  /**
   *
   * @type {string}
   * @memberof InlineResponse2009
   */
  label?: string;
  /**
   *
   * @type {number}
   * @memberof InlineResponse2009
   */
  eventCount?: number;
  /**
   *
   * @type {boolean}
   * @memberof InlineResponse2009
   */
  eventWarning?: boolean;
  /**
   *
   * @type {InlineResponse2009Analysis}
   * @memberof InlineResponse2009
   */
  analysis?: InlineResponse2009Analysis;
  /**
   *
   * @type {Array<InlineResponse2009Files>}
   * @memberof InlineResponse2009
   */
  files?: Array<InlineResponse2009Files>;
  /**
   *
   * @type {Array<InlineResponse2009Params>}
   * @memberof InlineResponse2009
   */
  params?: Array<InlineResponse2009Params>;
  /**
   *
   * @type {InlineResponse2009Spillover}
   * @memberof InlineResponse2009
   */
  spillover?: InlineResponse2009Spillover;
  /**
   *
   * @type {any}
   * @memberof InlineResponse2009
   */
  text?: any;
}
/**
 *
 * @export
 * @interface InlineResponse2009Analysis
 */
export interface InlineResponse2009Analysis {
  /**
   *
   * @type {string}
   * @memberof InlineResponse2009Analysis
   */
  fCSVersion?: string;
  /**
   *
   * @type {number}
   * @memberof InlineResponse2009Analysis
   */
  beginAnalysis?: number;
  /**
   *
   * @type {number}
   * @memberof InlineResponse2009Analysis
   */
  beginData?: number;
  /**
   *
   * @type {number}
   * @memberof InlineResponse2009Analysis
   */
  beginText?: number;
  /**
   *
   * @type {number}
   * @memberof InlineResponse2009Analysis
   */
  endAnalysis?: number;
  /**
   *
   * @type {number}
   * @memberof InlineResponse2009Analysis
   */
  endData?: number;
  /**
   *
   * @type {number}
   * @memberof InlineResponse2009Analysis
   */
  endText?: number;
}
/**
 *
 * @export
 * @interface InlineResponse2009Files
 */
export interface InlineResponse2009Files {
  /**
   *
   * @type {string}
   * @memberof InlineResponse2009Files
   */
  createdOn?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse2009Files
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse2009Files
   */
  label?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse2009Files
   */
  workspaceId?: string;
}
/**
 *
 * @export
 * @interface InlineResponse2009Params
 */
export interface InlineResponse2009Params {
  /**
   *
   * @type {string}
   * @memberof InlineResponse2009Params
   */
  display?: string;
  /**
   *
   * @type {number}
   * @memberof InlineResponse2009Params
   */
  key?: number;
  /**
   *
   * @type {string}
   * @memberof InlineResponse2009Params
   */
  value?: string;
}
/**
 *
 * @export
 * @interface InlineResponse2009Spillover
 */
export interface InlineResponse2009Spillover {
  /**
   *
   * @type {Array<string>}
   * @memberof InlineResponse2009Spillover
   */
  spilloverParamLabels?: Array<string>;
  /**
   *
   * @type {Array<Array<string>>}
   * @memberof InlineResponse2009Spillover
   */
  spilloverValues?: Array<Array<string>>;
}
/**
 *
 * @export
 * @interface InlineResponse200UserDetails
 */
export interface InlineResponse200UserDetails {
  /**
   *
   * @type {string}
   * @memberof InlineResponse200UserDetails
   */
  organisationId?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse200UserDetails
   */
  availableUntil?: string;
  /**
   *
   * @type {number}
   * @memberof InlineResponse200UserDetails
   */
  totalNumFilesPaidFor?: number;
  /**
   *
   * @type {number}
   * @memberof InlineResponse200UserDetails
   */
  totalFilesUploaded?: number;
}
/**
 *
 * @export
 * @interface InlineResponse400
 */
export interface InlineResponse400 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse400
   */
  message?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse400
   */
  token?: string;
}
/**
 *
 * @export
 * @interface InlineResponse4001
 */
export interface InlineResponse4001 {
  /**
   * Error message
   * @type {string}
   * @memberof InlineResponse4001
   */
  message?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse4001
   */
  token?: string;
}
/**
 * AuthenticationApi - fetch parameter creator
 * @export
 */
export const AuthenticationApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Let's user to login using Email and Password
     * @summary User Login
     * @param {Body} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userLogin(body?: Body, options: any = {}): FetchArgs {
      const localVarPath = `/api/login`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"Body" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * User registration by entering Organisation, Location, Email and Password
     * @summary Creating User Account
     * @param {Body1} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userResigter(body?: Body1, options: any = {}): FetchArgs {
      const localVarPath = `/api/register`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"Body1" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Let's user to login using Email and Password
     * @summary User Login
     * @param {Body} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userLogin(
      body?: Body,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
      const localVarFetchArgs = AuthenticationApiFetchParamCreator(
        configuration
      ).userLogin(body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * User registration by entering Organisation, Location, Email and Password
     * @summary Creating User Account
     * @param {Body1} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userResigter(
      body?: Body1,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
      const localVarFetchArgs = AuthenticationApiFetchParamCreator(
        configuration
      ).userResigter(body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     * Let's user to login using Email and Password
     * @summary User Login
     * @param {Body} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userLogin(body?: Body, options?: any) {
      return AuthenticationApiFp(configuration).userLogin(body, options)(
        fetch,
        basePath
      );
    },
    /**
     * User registration by entering Organisation, Location, Email and Password
     * @summary Creating User Account
     * @param {Body1} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userResigter(body?: Body1, options?: any) {
      return AuthenticationApiFp(configuration).userResigter(body, options)(
        fetch,
        basePath
      );
    },
  };
};

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
  /**
   * Let's user to login using Email and Password
   * @summary User Login
   * @param {Body} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationApi
   */
  public userLogin(body?: Body, options?: any) {
    return AuthenticationApiFp(this.configuration).userLogin(body, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   * User registration by entering Organisation, Location, Email and Password
   * @summary Creating User Account
   * @param {Body1} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationApi
   */
  public userResigter(body?: Body1, options?: any) {
    return AuthenticationApiFp(this.configuration).userResigter(body, options)(
      this.fetch,
      this.basePath
    );
  }
}
/**
 * ExperimentApi - fetch parameter creator
 * @export
 */
export const ExperimentApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    getAllExperiments(
      organisationId: string,
      token: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'organisationId' is not null or undefined
      if (organisationId === null || organisationId === undefined) {
        throw new RequiredError(
          "organisationId",
          "Required parameter organisationId was null or undefined when calling appWorkspace."
        );
      }
      // verify required parameter 'token' is not null or undefined
      if (token === null || token === undefined) {
        throw new RequiredError(
          "token",
          "Required parameter token was null or undefined when calling appWorkspace."
        );
      }
      const localVarPath = `/api/organization/${organisationId}/experiments`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (organisationId !== undefined) {
        localVarQueryParameter["organisationId"] = organisationId;
      }

      if (token !== undefined && token !== null) {
        localVarHeaderParameter["token"] = String(token);
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * To create Experiment, we need to pass workspaceId, data and details in body of request
     * @summary Creating Experiment
     * @param {ExperimentPayload} body
     * @param {string} token Generate token and pass it in header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createExperiment(
      body: ExperimentPayload,
      token: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling createExperiment."
        );
      }
      // verify required parameter 'token' is not null or undefined
      if (token === null || token === undefined) {
        throw new RequiredError(
          "token",
          "Required parameter token was null or undefined when calling createExperiment."
        );
      }

      const localVarPath = `/api/experiment`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (token !== undefined && token !== null) {
        localVarHeaderParameter["token"] = String(token);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"ExperimentPayload" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * To get experiments, you must pass the target experimentId
     * @summary Get experiments
     * @param {string} token Generate token and pass it in header
     * @param {string} experimentId Experiment id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExperiment(
      token: string,
      experimentId: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'token' is not null or undefined
      if (token === null || token === undefined) {
        throw new RequiredError(
          "token",
          "Required parameter token was null or undefined when calling getExperiment."
        );
      }
      // verify required parameter 'workspaceId' is not null or undefined
      if (experimentId === null || experimentId === undefined) {
        throw new RequiredError(
          "experimentId",
          "Required parameter experimentId was null or undefined when calling getExperiment."
        );
      }
      const localVarPath = `/api/getExperiment`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (token !== undefined && token !== null) {
        localVarHeaderParameter["token"] = String(token);
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * To create Experiment, we need to pass workspaceId, data and details in body of request
     * @summary Creating Experiment
     * @param {ExperimentPayload} body
     * @param {string} token Generate token and pass it in header
     * @param {string} workspaceId Workspace id
     * @param {string} experimentId Experiment id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateExperiment(
      body: ExperimentPayload,
      token: string,
      workspaceId: string,
      experimentId: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling updateExperiment."
        );
      }
      // verify required parameter 'token' is not null or undefined
      if (token === null || token === undefined) {
        throw new RequiredError(
          "token",
          "Required parameter token was null or undefined when calling updateExperiment."
        );
      }
      // verify required parameter 'workspaceId' is not null or undefined
      if (workspaceId === null || workspaceId === undefined) {
        throw new RequiredError(
          "workspaceId",
          "Required parameter workspaceId was null or undefined when calling updateExperiment."
        );
      }
      // verify required parameter 'experimentId' is not null or undefined
      if (experimentId === null || experimentId === undefined) {
        throw new RequiredError(
          "experimentId",
          "Required parameter experimentId was null or undefined when calling updateExperiment."
        );
      }
      const localVarPath =
        `/api/workspace/{workspaceId}/experiment/{experimentId}`
          .replace(
            `{${"workspaceId"}}`,
            encodeURIComponent(String(workspaceId))
          )
          .replace(
            `{${"experimentId"}}`,
            encodeURIComponent(String(experimentId))
          );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "PUT" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (token !== undefined && token !== null) {
        localVarHeaderParameter["token"] = String(token);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"ExperimentPayload" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * To delete workspace, we need to pass workspaceId and workspaceName as query parameters
     * @summary Deleting Experiments
     * @param {string} experimentId ExperimentId
     * @param {string} token Generate token and pass it in header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteExperiment(
      experimentId: string,
      token: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'experimentId' is not null or undefined
      if (experimentId === null || experimentId === undefined) {
        throw new RequiredError(
          "experimentId",
          "Required parameter experimentId was null or undefined when calling deleteExperiment."
        );
      }
      // verify required parameter 'token' is not null or undefined
      if (token === null || token === undefined) {
        throw new RequiredError(
          "token",
          "Required parameter token was null or undefined when calling deleteExperiment."
        );
      }
      const localVarPath = `/api/experiment/delete`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: "DELETE" },
        options
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (experimentId !== undefined) {
        localVarQueryParameter["experimentId"] = experimentId;
      }

      if (token !== undefined && token !== null) {
        localVarHeaderParameter["token"] = String(token);
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * To edit workspace, we need to pass workspaceId and workspaceName as query parameters
     * @summary Editing Experiment Name
     * @param {string} experimentId ExperimentId
     * @param {string} experimentName workspaceName
     * @param {string} token Generate token and pass it in header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editExperimentName(
      experimentId: string,
      experimentName: string,
      token: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'workspaceId' is not null or undefined
      if (experimentId === null || experimentId === undefined) {
        throw new RequiredError(
          "workspaceId",
          "Required parameter workspaceId was null or undefined when calling editExperiment."
        );
      }
      // verify required parameter 'workspaceName' is not null or undefined
      if (experimentName === null || experimentName === undefined) {
        throw new RequiredError(
          "workspaceName",
          "Required parameter workspaceName was null or undefined when calling editExperiment."
        );
      }
      // verify required parameter 'token' is not null or undefined
      if (token === null || token === undefined) {
        throw new RequiredError(
          "token",
          "Required parameter token was null or undefined when calling editExperiment."
        );
      }
      const localVarPath = `/api/experiment/edit/name`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "PUT" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (experimentId !== undefined) {
        localVarQueryParameter["experimentId"] = experimentId;
      }

      if (experimentName !== undefined) {
        localVarQueryParameter["experimentName"] = experimentName;
      }

      if (token !== undefined && token !== null) {
        localVarHeaderParameter["token"] = String(token);
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ExperimentApi - functional programming interface
 * @export
 */
export const ExperimentApiFp = function (configuration?: Configuration) {
  return {
    /**
     * To create Experiment, we need to pass workspaceId, data and details in body of request
     * @summary Creating Experiment
     * @param {ExperimentPayload} body
     * @param {string} token Generate token and pass it in header
     * @param {string} workspaceId Workspace id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createExperiment(
      body: ExperimentPayload,
      token: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2006> {
      const localVarFetchArgs = ExperimentApiFetchParamCreator(
        configuration
      ).createExperiment(body, token, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * To get experiments, you must pass the target experimentId
     * @summary Get experiments
     * @param {string} token Generate token and pass it in header
     * @param {string} experimentId Experiment id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExperiment(
      token: string,
      experimentId: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2006> {
      const localVarFetchArgs = ExperimentApiFetchParamCreator(
        configuration
      ).getExperiment(token, experimentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * To create Experiment, we need to pass workspaceId, data and details in body of request
     * @summary Creating Experiment
     * @param {ExperimentPayload} body
     * @param {string} token Generate token and pass it in header
     * @param {string} experimentId Experiment id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateExperiment(
      body: ExperimentPayload,
      token: string,
      experimentId: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2007> {
      const localVarFetchArgs = ExperimentApiFetchParamCreator(
        configuration
      ).updateExperiment(body, token, experimentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * ExperimentApi - factory interface
 * @export
 */
export const ExperimentApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     * To create Experiment, we need to pass workspaceId, data and details in body of request
     * @summary Creating Experiment
     * @param {ExperimentPayload} body
     * @param {string} token Generate token and pass it in header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createExperiment(body: ExperimentPayload, token: string, options?: any) {
      return ExperimentApiFp(configuration).createExperiment(
        body,
        token,
        options
      )(fetch, basePath);
    },
    /**
     * To get experiments, you must pass the target experimentId
     * @summary Get experiments
     * @param {string} token Generate token and pass it in header
     * @param {string} experimentId Experiment id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExperiment(token: string, experimentId: string, options?: any) {
      return ExperimentApiFp(configuration).getExperiment(
        token,
        experimentId,
        options
      )(fetch, basePath);
    },
    /**
     * To create Experiment, we need to pass experimentId, data and details in body of request
     * @summary Creating Experiment
     * @param {ExperimentPayload} body
     * @param {string} token Generate token and pass it in header
     * @param {string} experimentId Experiment id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateExperiment(
      body: ExperimentPayload,
      token: string,
      experimentId: string,
      options?: any
    ) {
      return ExperimentApiFp(configuration).updateExperiment(
        body,
        token,
        experimentId,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * ExperimentApi - object-oriented interface
 * @export
 * @class ExperimentApi
 * @extends {BaseAPI}
 */
export class ExperimentApi extends BaseAPI {
  /**
   * To create Experiment, we need to pass experimentId, data and details in body of request
   * @summary Creating Experiment
   * @param {ExperimentPayload} body
   * @param {string} token Generate token and pass it in header
   * @param {string} experimentId Experiment id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExperimentApi
   */
  public createExperiment(
    body: ExperimentPayload,
    token: string,
    options?: any
  ) {
    return ExperimentApiFp(this.configuration).createExperiment(
      body,
      token,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * To get experiments, you must pass the target experimentId
   * @summary Get experiments
   * @param {string} token Generate token and pass it in header
   * @param {string} experimentId Experiment id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExperimentApi
   */
  public getExperiment(token: string, experimentId: string, options?: any) {
    return ExperimentApiFp(this.configuration).getExperiment(
      token,
      experimentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * To create Experiment, we need to pass experimentId, data and details in body of request
   * @summary Creating Experiment
   * @param {ExperimentPayload} body
   * @param {string} token Generate token and pass it in header
   * @param {string} experimentId Experiment id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExperimentApi
   */
  public updateExperiment(
    body: ExperimentPayload,
    token: string,
    experimentId: string,
    options?: any
  ) {
    return ExperimentApiFp(this.configuration).updateExperiment(
      body,
      token,
      experimentId,
      options
    )(this.fetch, this.basePath);
  }
}
/**
 * GraphsGatesApi - fetch parameter creator
 * @export
 */
export const GraphsGatesApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Delete graph
     * @param {string} token Generate token and pass it in header
     * @param {Body6} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGraph(token: string, body?: Body6, options: any = {}): FetchArgs {
      // verify required parameter 'token' is not null or undefined
      if (token === null || token === undefined) {
        throw new RequiredError(
          "token",
          "Required parameter token was null or undefined when calling deleteGraph."
        );
      }
      const localVarPath = `/api/delete/graph`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (token !== undefined && token !== null) {
        localVarHeaderParameter["token"] = String(token);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"Body6" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Getting File Info
     * @param {string} organisationId Organisation Id of logged in user
     * @param {string} workspaceId Workspace Id
     * @param {string} id File Id
     * @param {string} token token is passed in header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fileInfo(
      organisationId: string,
      workspaceId: string,
      id: string,
      token: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'organisationId' is not null or undefined
      if (organisationId === null || organisationId === undefined) {
        throw new RequiredError(
          "organisationId",
          "Required parameter organisationId was null or undefined when calling fileInfo."
        );
      }
      // verify required parameter 'workspaceId' is not null or undefined
      if (workspaceId === null || workspaceId === undefined) {
        throw new RequiredError(
          "workspaceId",
          "Required parameter workspaceId was null or undefined when calling fileInfo."
        );
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling fileInfo."
        );
      }
      // verify required parameter 'token' is not null or undefined
      if (token === null || token === undefined) {
        throw new RequiredError(
          "token",
          "Required parameter token was null or undefined when calling fileInfo."
        );
      }
      const localVarPath = `/api/canvas/info`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (organisationId !== undefined) {
        localVarQueryParameter["organisationId"] = organisationId;
      }

      if (workspaceId !== undefined) {
        localVarQueryParameter["workspaceId"] = workspaceId;
      }

      if (id !== undefined) {
        localVarQueryParameter["id"] = id;
      }

      if (token !== undefined && token !== null) {
        localVarHeaderParameter["token"] = String(token);
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Getting Canvas
     * @param {string} workspaceId Workspace Id
     * @param {string} organisationId Organisation Id
     * @param {string} fileIds File Id
     * @param {string} currentFileId File Id
     * @param {number} height Height of Graph
     * @param {number} width width of Graph
     * @param {string} paramX
     * @param {string} paramY
     * @param {string} selectedGate
     * @param {string} xScale
     * @param {string} yScale
     * @param {string} token token is passed in header
     * @param {string} [chartType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCanvas(
      workspaceId: string,
      organisationId: string,
      fileIds: string,
      currentFileId: string,
      height: number,
      width: number,
      paramX: string,
      paramY: string,
      selectedGate: string,
      xScale: string,
      yScale: string,
      token: string,
      chartType?: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'workspaceId' is not null or undefined
      if (workspaceId === null || workspaceId === undefined) {
        throw new RequiredError(
          "workspaceId",
          "Required parameter workspaceId was null or undefined when calling getCanvas."
        );
      }
      // verify required parameter 'organisationId' is not null or undefined
      if (organisationId === null || organisationId === undefined) {
        throw new RequiredError(
          "organisationId",
          "Required parameter organisationId was null or undefined when calling getCanvas."
        );
      }
      // verify required parameter 'fileIds' is not null or undefined
      if (fileIds === null || fileIds === undefined) {
        throw new RequiredError(
          "fileIds",
          "Required parameter fileIds was null or undefined when calling getCanvas."
        );
      }
      // verify required parameter 'currentFileId' is not null or undefined
      if (currentFileId === null || currentFileId === undefined) {
        throw new RequiredError(
          "currentFileId",
          "Required parameter currentFileId was null or undefined when calling getCanvas."
        );
      }
      // verify required parameter 'height' is not null or undefined
      if (height === null || height === undefined) {
        throw new RequiredError(
          "height",
          "Required parameter height was null or undefined when calling getCanvas."
        );
      }
      // verify required parameter 'width' is not null or undefined
      if (width === null || width === undefined) {
        throw new RequiredError(
          "width",
          "Required parameter width was null or undefined when calling getCanvas."
        );
      }
      // verify required parameter 'paramX' is not null or undefined
      if (paramX === null || paramX === undefined) {
        throw new RequiredError(
          "paramX",
          "Required parameter paramX was null or undefined when calling getCanvas."
        );
      }
      // verify required parameter 'paramY' is not null or undefined
      if (paramY === null || paramY === undefined) {
        throw new RequiredError(
          "paramY",
          "Required parameter paramY was null or undefined when calling getCanvas."
        );
      }
      // verify required parameter 'selectedGate' is not null or undefined
      if (selectedGate === null || selectedGate === undefined) {
        throw new RequiredError(
          "selectedGate",
          "Required parameter selectedGate was null or undefined when calling getCanvas."
        );
      }
      // verify required parameter 'xScale' is not null or undefined
      if (xScale === null || xScale === undefined) {
        throw new RequiredError(
          "xScale",
          "Required parameter xScale was null or undefined when calling getCanvas."
        );
      }
      // verify required parameter 'yScale' is not null or undefined
      if (yScale === null || yScale === undefined) {
        throw new RequiredError(
          "yScale",
          "Required parameter yScale was null or undefined when calling getCanvas."
        );
      }
      // verify required parameter 'token' is not null or undefined
      if (token === null || token === undefined) {
        throw new RequiredError(
          "token",
          "Required parameter token was null or undefined when calling getCanvas."
        );
      }
      const localVarPath = `/api/canvas`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (workspaceId !== undefined) {
        localVarQueryParameter["workspaceId"] = workspaceId;
      }

      if (organisationId !== undefined) {
        localVarQueryParameter["organisationId"] = organisationId;
      }

      if (fileIds !== undefined) {
        localVarQueryParameter["fileIds"] = fileIds;
      }

      if (currentFileId !== undefined) {
        localVarQueryParameter["currentFileId"] = currentFileId;
      }

      if (height !== undefined) {
        localVarQueryParameter["height"] = height;
      }

      if (width !== undefined) {
        localVarQueryParameter["width"] = width;
      }

      if (chartType !== undefined) {
        localVarQueryParameter["chartType"] = chartType;
      }

      if (paramX !== undefined) {
        localVarQueryParameter["paramX"] = paramX;
      }

      if (paramY !== undefined) {
        localVarQueryParameter["paramY"] = paramY;
      }

      if (selectedGate !== undefined) {
        localVarQueryParameter["selectedGate"] = selectedGate;
      }

      if (xScale !== undefined) {
        localVarQueryParameter["xScale"] = xScale;
      }

      if (yScale !== undefined) {
        localVarQueryParameter["yScale"] = yScale;
      }

      if (token !== undefined && token !== null) {
        localVarHeaderParameter["token"] = String(token);
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Getting Gates
     * @param {string} workspaceId Workspace Id
     * @param {string} token token is passed in header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGates(workspaceId: string, token: string, options: any = {}): FetchArgs {
      // verify required parameter 'workspaceId' is not null or undefined
      if (workspaceId === null || workspaceId === undefined) {
        throw new RequiredError(
          "workspaceId",
          "Required parameter workspaceId was null or undefined when calling getGates."
        );
      }
      // verify required parameter 'token' is not null or undefined
      if (token === null || token === undefined) {
        throw new RequiredError(
          "token",
          "Required parameter token was null or undefined when calling getGates."
        );
      }
      const localVarPath = `/api/get/gates`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (workspaceId !== undefined) {
        localVarQueryParameter["workspaceId"] = workspaceId;
      }

      if (token !== undefined && token !== null) {
        localVarHeaderParameter["token"] = String(token);
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Getting Graphs
     * @param {string} workspaceId Workspace Id
     * @param {string} organisationId Organisation Id
     * @param {string} id File Id
     * @param {number} height Height of Graph
     * @param {number} width width of Graph
     * @param {string} token token is passed in header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGraphs(
      workspaceId: string,
      organisationId: string,
      id: string,
      height: number,
      width: number,
      token: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'workspaceId' is not null or undefined
      if (workspaceId === null || workspaceId === undefined) {
        throw new RequiredError(
          "workspaceId",
          "Required parameter workspaceId was null or undefined when calling getGraphs."
        );
      }
      // verify required parameter 'organisationId' is not null or undefined
      if (organisationId === null || organisationId === undefined) {
        throw new RequiredError(
          "organisationId",
          "Required parameter organisationId was null or undefined when calling getGraphs."
        );
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling getGraphs."
        );
      }
      // verify required parameter 'height' is not null or undefined
      if (height === null || height === undefined) {
        throw new RequiredError(
          "height",
          "Required parameter height was null or undefined when calling getGraphs."
        );
      }
      // verify required parameter 'width' is not null or undefined
      if (width === null || width === undefined) {
        throw new RequiredError(
          "width",
          "Required parameter width was null or undefined when calling getGraphs."
        );
      }
      // verify required parameter 'token' is not null or undefined
      if (token === null || token === undefined) {
        throw new RequiredError(
          "token",
          "Required parameter token was null or undefined when calling getGraphs."
        );
      }
      const localVarPath = `/api/get/graphs`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (workspaceId !== undefined) {
        localVarQueryParameter["workspaceId"] = workspaceId;
      }

      if (organisationId !== undefined) {
        localVarQueryParameter["organisationId"] = organisationId;
      }

      if (id !== undefined) {
        localVarQueryParameter["id"] = id;
      }

      if (height !== undefined) {
        localVarQueryParameter["height"] = height;
      }

      if (width !== undefined) {
        localVarQueryParameter["width"] = width;
      }

      if (token !== undefined && token !== null) {
        localVarHeaderParameter["token"] = String(token);
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Quad Gate
     * @param {string} organisationId organisation Id
     * @param {string} id file Id
     * @param {number} coordX
     * @param {number} coordY
     * @param {number} paramX
     * @param {number} paramY
     * @param {string} parent
     * @param {string} yScale
     * @param {string} xScale
     * @param {number} width
     * @param {number} height
     * @param {string} token token is passed in header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    quadGate(
      organisationId: string,
      id: string,
      coordX: number,
      coordY: number,
      paramX: number,
      paramY: number,
      parent: string,
      yScale: string,
      xScale: string,
      width: number,
      height: number,
      token: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'organisationId' is not null or undefined
      if (organisationId === null || organisationId === undefined) {
        throw new RequiredError(
          "organisationId",
          "Required parameter organisationId was null or undefined when calling quadGate."
        );
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling quadGate."
        );
      }
      // verify required parameter 'coordX' is not null or undefined
      if (coordX === null || coordX === undefined) {
        throw new RequiredError(
          "coordX",
          "Required parameter coordX was null or undefined when calling quadGate."
        );
      }
      // verify required parameter 'coordY' is not null or undefined
      if (coordY === null || coordY === undefined) {
        throw new RequiredError(
          "coordY",
          "Required parameter coordY was null or undefined when calling quadGate."
        );
      }
      // verify required parameter 'paramX' is not null or undefined
      if (paramX === null || paramX === undefined) {
        throw new RequiredError(
          "paramX",
          "Required parameter paramX was null or undefined when calling quadGate."
        );
      }
      // verify required parameter 'paramY' is not null or undefined
      if (paramY === null || paramY === undefined) {
        throw new RequiredError(
          "paramY",
          "Required parameter paramY was null or undefined when calling quadGate."
        );
      }
      // verify required parameter 'parent' is not null or undefined
      if (parent === null || parent === undefined) {
        throw new RequiredError(
          "parent",
          "Required parameter parent was null or undefined when calling quadGate."
        );
      }
      // verify required parameter 'yScale' is not null or undefined
      if (yScale === null || yScale === undefined) {
        throw new RequiredError(
          "yScale",
          "Required parameter yScale was null or undefined when calling quadGate."
        );
      }
      // verify required parameter 'xScale' is not null or undefined
      if (xScale === null || xScale === undefined) {
        throw new RequiredError(
          "xScale",
          "Required parameter xScale was null or undefined when calling quadGate."
        );
      }
      // verify required parameter 'width' is not null or undefined
      if (width === null || width === undefined) {
        throw new RequiredError(
          "width",
          "Required parameter width was null or undefined when calling quadGate."
        );
      }
      // verify required parameter 'height' is not null or undefined
      if (height === null || height === undefined) {
        throw new RequiredError(
          "height",
          "Required parameter height was null or undefined when calling quadGate."
        );
      }
      // verify required parameter 'token' is not null or undefined
      if (token === null || token === undefined) {
        throw new RequiredError(
          "token",
          "Required parameter token was null or undefined when calling quadGate."
        );
      }
      const localVarPath = `/api/set/quadgate`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (organisationId !== undefined) {
        localVarQueryParameter["organisationId"] = organisationId;
      }

      if (id !== undefined) {
        localVarQueryParameter["id"] = id;
      }

      if (coordX !== undefined) {
        localVarQueryParameter["coordX"] = coordX;
      }

      if (coordY !== undefined) {
        localVarQueryParameter["coordY"] = coordY;
      }

      if (paramX !== undefined) {
        localVarQueryParameter["paramX"] = paramX;
      }

      if (paramY !== undefined) {
        localVarQueryParameter["paramY"] = paramY;
      }

      if (parent !== undefined) {
        localVarQueryParameter["parent"] = parent;
      }

      if (yScale !== undefined) {
        localVarQueryParameter["yScale"] = yScale;
      }

      if (xScale !== undefined) {
        localVarQueryParameter["xScale"] = xScale;
      }

      if (width !== undefined) {
        localVarQueryParameter["width"] = width;
      }

      if (height !== undefined) {
        localVarQueryParameter["height"] = height;
      }

      if (token !== undefined && token !== null) {
        localVarHeaderParameter["token"] = String(token);
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Setting Gate
     * @param {string} workspaceId Workspace Id
     * @param {string} organisationId organisation Id
     * @param {string} id file Id
     * @param {string} gateNameUser
     * @param {GatingCoords} gatingCoords
     * @param {number} paramX
     * @param {number} paramY
     * @param {string} parent
     * @param {string} yScale
     * @param {string} xScale
     * @param {number} width
     * @param {number} height
     * @param {string} token token is passed in header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setGate(
      workspaceId: string,
      organisationId: string,
      id: string,
      gateNameUser: string,
      gatingCoords: GatingCoords,
      paramX: number,
      paramY: number,
      parent: string,
      yScale: string,
      xScale: string,
      width: number,
      height: number,
      token: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'workspaceId' is not null or undefined
      if (workspaceId === null || workspaceId === undefined) {
        throw new RequiredError(
          "workspaceId",
          "Required parameter workspaceId was null or undefined when calling setGate."
        );
      }
      // verify required parameter 'organisationId' is not null or undefined
      if (organisationId === null || organisationId === undefined) {
        throw new RequiredError(
          "organisationId",
          "Required parameter organisationId was null or undefined when calling setGate."
        );
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling setGate."
        );
      }
      // verify required parameter 'gateNameUser' is not null or undefined
      if (gateNameUser === null || gateNameUser === undefined) {
        throw new RequiredError(
          "gateNameUser",
          "Required parameter gateNameUser was null or undefined when calling setGate."
        );
      }
      // verify required parameter 'gatingCoords' is not null or undefined
      if (gatingCoords === null || gatingCoords === undefined) {
        throw new RequiredError(
          "gatingCoords",
          "Required parameter gatingCoords was null or undefined when calling setGate."
        );
      }
      // verify required parameter 'paramX' is not null or undefined
      if (paramX === null || paramX === undefined) {
        throw new RequiredError(
          "paramX",
          "Required parameter paramX was null or undefined when calling setGate."
        );
      }
      // verify required parameter 'paramY' is not null or undefined
      if (paramY === null || paramY === undefined) {
        throw new RequiredError(
          "paramY",
          "Required parameter paramY was null or undefined when calling setGate."
        );
      }
      // verify required parameter 'parent' is not null or undefined
      if (parent === null || parent === undefined) {
        throw new RequiredError(
          "parent",
          "Required parameter parent was null or undefined when calling setGate."
        );
      }
      // verify required parameter 'yScale' is not null or undefined
      if (yScale === null || yScale === undefined) {
        throw new RequiredError(
          "yScale",
          "Required parameter yScale was null or undefined when calling setGate."
        );
      }
      // verify required parameter 'xScale' is not null or undefined
      if (xScale === null || xScale === undefined) {
        throw new RequiredError(
          "xScale",
          "Required parameter xScale was null or undefined when calling setGate."
        );
      }
      // verify required parameter 'width' is not null or undefined
      if (width === null || width === undefined) {
        throw new RequiredError(
          "width",
          "Required parameter width was null or undefined when calling setGate."
        );
      }
      // verify required parameter 'height' is not null or undefined
      if (height === null || height === undefined) {
        throw new RequiredError(
          "height",
          "Required parameter height was null or undefined when calling setGate."
        );
      }
      // verify required parameter 'token' is not null or undefined
      if (token === null || token === undefined) {
        throw new RequiredError(
          "token",
          "Required parameter token was null or undefined when calling setGate."
        );
      }
      const localVarPath = `/api/set/gate`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (workspaceId !== undefined) {
        localVarQueryParameter["workspaceId"] = workspaceId;
      }

      if (organisationId !== undefined) {
        localVarQueryParameter["organisationId"] = organisationId;
      }

      if (id !== undefined) {
        localVarQueryParameter["id"] = id;
      }

      if (gateNameUser !== undefined) {
        localVarQueryParameter["gateNameUser"] = gateNameUser;
      }

      if (gatingCoords !== undefined) {
        localVarQueryParameter["gatingCoords"] = gatingCoords;
      }

      if (paramX !== undefined) {
        localVarQueryParameter["paramX"] = paramX;
      }

      if (paramY !== undefined) {
        localVarQueryParameter["paramY"] = paramY;
      }

      if (parent !== undefined) {
        localVarQueryParameter["parent"] = parent;
      }

      if (yScale !== undefined) {
        localVarQueryParameter["yScale"] = yScale;
      }

      if (xScale !== undefined) {
        localVarQueryParameter["xScale"] = xScale;
      }

      if (width !== undefined) {
        localVarQueryParameter["width"] = width;
      }

      if (height !== undefined) {
        localVarQueryParameter["height"] = height;
      }

      if (token !== undefined && token !== null) {
        localVarHeaderParameter["token"] = String(token);
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create graph
     * @param {string} token Generate token and pass it in header
     * @param {any} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setGraph(token: string, body?: any, options: any = {}): FetchArgs {
      // verify required parameter 'token' is not null or undefined
      if (token === null || token === undefined) {
        throw new RequiredError(
          "token",
          "Required parameter token was null or undefined when calling setGraph."
        );
      }
      const localVarPath = `/api/set/graph`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (token !== undefined && token !== null) {
        localVarHeaderParameter["token"] = String(token);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"any" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Getting Statistics
     * @param {string} organisationId Organisation Id of logged in user
     * @param {string} selectedGate Selected Gate
     * @param {string} id File Id
     * @param {string} token token is passed in header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    statistics(
      organisationId: string,
      selectedGate: string,
      id: string,
      token: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'organisationId' is not null or undefined
      if (organisationId === null || organisationId === undefined) {
        throw new RequiredError(
          "organisationId",
          "Required parameter organisationId was null or undefined when calling statistics."
        );
      }
      // verify required parameter 'selectedGate' is not null or undefined
      if (selectedGate === null || selectedGate === undefined) {
        throw new RequiredError(
          "selectedGate",
          "Required parameter selectedGate was null or undefined when calling statistics."
        );
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling statistics."
        );
      }
      // verify required parameter 'token' is not null or undefined
      if (token === null || token === undefined) {
        throw new RequiredError(
          "token",
          "Required parameter token was null or undefined when calling statistics."
        );
      }
      const localVarPath = `/api/get/statistics`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (organisationId !== undefined) {
        localVarQueryParameter["organisationId"] = organisationId;
      }

      if (selectedGate !== undefined) {
        localVarQueryParameter["selectedGate"] = selectedGate;
      }

      if (id !== undefined) {
        localVarQueryParameter["id"] = id;
      }

      if (token !== undefined && token !== null) {
        localVarHeaderParameter["token"] = String(token);
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update graph
     * @param {string} token Generate token and pass it in header
     * @param {Body5} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGraph(token: string, body?: Body5, options: any = {}): FetchArgs {
      // verify required parameter 'token' is not null or undefined
      if (token === null || token === undefined) {
        throw new RequiredError(
          "token",
          "Required parameter token was null or undefined when calling updateGraph."
        );
      }
      const localVarPath = `/api/update/graph`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (token !== undefined && token !== null) {
        localVarHeaderParameter["token"] = String(token);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"Body5" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * GraphsGatesApi - functional programming interface
 * @export
 */
export const GraphsGatesApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Delete graph
     * @param {string} token Generate token and pass it in header
     * @param {Body6} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGraph(
      token: string,
      body?: Body6,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2005> {
      const localVarFetchArgs = GraphsGatesApiFetchParamCreator(
        configuration
      ).deleteGraph(token, body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Getting File Info
     * @param {string} organisationId Organisation Id of logged in user
     * @param {string} workspaceId Workspace Id
     * @param {string} id File Id
     * @param {string} token token is passed in header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fileInfo(
      organisationId: string,
      workspaceId: string,
      id: string,
      token: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2009> {
      const localVarFetchArgs = GraphsGatesApiFetchParamCreator(
        configuration
      ).fileInfo(organisationId, workspaceId, id, token, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Getting Canvas
     * @param {string} workspaceId Workspace Id
     * @param {string} organisationId Organisation Id
     * @param {string} fileIds File Id
     * @param {string} currentFileId File Id
     * @param {number} height Height of Graph
     * @param {number} width width of Graph
     * @param {string} paramX
     * @param {string} paramY
     * @param {string} selectedGate
     * @param {string} xScale
     * @param {string} yScale
     * @param {string} token token is passed in header
     * @param {string} [chartType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCanvas(
      workspaceId: string,
      organisationId: string,
      fileIds: string,
      currentFileId: string,
      height: number,
      width: number,
      paramX: string,
      paramY: string,
      selectedGate: string,
      xScale: string,
      yScale: string,
      token: string,
      chartType?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
      const localVarFetchArgs = GraphsGatesApiFetchParamCreator(
        configuration
      ).getCanvas(
        workspaceId,
        organisationId,
        fileIds,
        currentFileId,
        height,
        width,
        paramX,
        paramY,
        selectedGate,
        xScale,
        yScale,
        token,
        chartType,
        options
      );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Getting Gates
     * @param {string} workspaceId Workspace Id
     * @param {string} token token is passed in header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGates(
      workspaceId: string,
      token: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<any>> {
      const localVarFetchArgs = GraphsGatesApiFetchParamCreator(
        configuration
      ).getGates(workspaceId, token, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Getting Graphs
     * @param {string} workspaceId Workspace Id
     * @param {string} organisationId Organisation Id
     * @param {string} id File Id
     * @param {number} height Height of Graph
     * @param {number} width width of Graph
     * @param {string} token token is passed in header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGraphs(
      workspaceId: string,
      organisationId: string,
      id: string,
      height: number,
      width: number,
      token: string,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<Array<InlineResponse20011>> {
      const localVarFetchArgs = GraphsGatesApiFetchParamCreator(
        configuration
      ).getGraphs(
        workspaceId,
        organisationId,
        id,
        height,
        width,
        token,
        options
      );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Quad Gate
     * @param {string} organisationId organisation Id
     * @param {string} id file Id
     * @param {number} coordX
     * @param {number} coordY
     * @param {number} paramX
     * @param {number} paramY
     * @param {string} parent
     * @param {string} yScale
     * @param {string} xScale
     * @param {number} width
     * @param {number} height
     * @param {string} token token is passed in header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    quadGate(
      organisationId: string,
      id: string,
      coordX: number,
      coordY: number,
      paramX: number,
      paramY: number,
      parent: string,
      yScale: string,
      xScale: string,
      width: number,
      height: number,
      token: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20012> {
      const localVarFetchArgs = GraphsGatesApiFetchParamCreator(
        configuration
      ).quadGate(
        organisationId,
        id,
        coordX,
        coordY,
        paramX,
        paramY,
        parent,
        yScale,
        xScale,
        width,
        height,
        token,
        options
      );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Setting Gate
     * @param {string} workspaceId Workspace Id
     * @param {string} organisationId organisation Id
     * @param {string} id file Id
     * @param {string} gateNameUser
     * @param {GatingCoords} gatingCoords
     * @param {number} paramX
     * @param {number} paramY
     * @param {string} parent
     * @param {string} yScale
     * @param {string} xScale
     * @param {number} width
     * @param {number} height
     * @param {string} token token is passed in header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setGate(
      workspaceId: string,
      organisationId: string,
      id: string,
      gateNameUser: string,
      gatingCoords: GatingCoords,
      paramX: number,
      paramY: number,
      parent: string,
      yScale: string,
      xScale: string,
      width: number,
      height: number,
      token: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<any>> {
      const localVarFetchArgs = GraphsGatesApiFetchParamCreator(
        configuration
      ).setGate(
        workspaceId,
        organisationId,
        id,
        gateNameUser,
        gatingCoords,
        paramX,
        paramY,
        parent,
        yScale,
        xScale,
        width,
        height,
        token,
        options
      );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Create graph
     * @param {string} token Generate token and pass it in header
     * @param {any} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setGraph(
      token: string,
      body?: any,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<any>> {
      const localVarFetchArgs = GraphsGatesApiFetchParamCreator(
        configuration
      ).setGraph(token, body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Getting Statistics
     * @param {string} organisationId Organisation Id of logged in user
     * @param {string} selectedGate Selected Gate
     * @param {string} id File Id
     * @param {string} token token is passed in header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    statistics(
      organisationId: string,
      selectedGate: string,
      id: string,
      token: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20010> {
      const localVarFetchArgs = GraphsGatesApiFetchParamCreator(
        configuration
      ).statistics(organisationId, selectedGate, id, token, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Update graph
     * @param {string} token Generate token and pass it in header
     * @param {Body5} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGraph(
      token: string,
      body?: Body5,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2005> {
      const localVarFetchArgs = GraphsGatesApiFetchParamCreator(
        configuration
      ).updateGraph(token, body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * GraphsGatesApi - factory interface
 * @export
 */
export const GraphsGatesApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Delete graph
     * @param {string} token Generate token and pass it in header
     * @param {Body6} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGraph(token: string, body?: Body6, options?: any) {
      return GraphsGatesApiFp(configuration).deleteGraph(
        token,
        body,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Getting File Info
     * @param {string} organisationId Organisation Id of logged in user
     * @param {string} workspaceId Workspace Id
     * @param {string} id File Id
     * @param {string} token token is passed in header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fileInfo(
      organisationId: string,
      workspaceId: string,
      id: string,
      token: string,
      options?: any
    ) {
      return GraphsGatesApiFp(configuration).fileInfo(
        organisationId,
        workspaceId,
        id,
        token,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Getting Canvas
     * @param {string} workspaceId Workspace Id
     * @param {string} organisationId Organisation Id
     * @param {string} fileIds File Id
     * @param {string} currentFileId File Id
     * @param {number} height Height of Graph
     * @param {number} width width of Graph
     * @param {string} paramX
     * @param {string} paramY
     * @param {string} selectedGate
     * @param {string} xScale
     * @param {string} yScale
     * @param {string} token token is passed in header
     * @param {string} [chartType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCanvas(
      workspaceId: string,
      organisationId: string,
      fileIds: string,
      currentFileId: string,
      height: number,
      width: number,
      paramX: string,
      paramY: string,
      selectedGate: string,
      xScale: string,
      yScale: string,
      token: string,
      chartType?: string,
      options?: any
    ) {
      return GraphsGatesApiFp(configuration).getCanvas(
        workspaceId,
        organisationId,
        fileIds,
        currentFileId,
        height,
        width,
        paramX,
        paramY,
        selectedGate,
        xScale,
        yScale,
        token,
        chartType,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Getting Gates
     * @param {string} workspaceId Workspace Id
     * @param {string} token token is passed in header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGates(workspaceId: string, token: string, options?: any) {
      return GraphsGatesApiFp(configuration).getGates(
        workspaceId,
        token,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Getting Graphs
     * @param {string} workspaceId Workspace Id
     * @param {string} organisationId Organisation Id
     * @param {string} id File Id
     * @param {number} height Height of Graph
     * @param {number} width width of Graph
     * @param {string} token token is passed in header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGraphs(
      workspaceId: string,
      organisationId: string,
      id: string,
      height: number,
      width: number,
      token: string,
      options?: any
    ) {
      return GraphsGatesApiFp(configuration).getGraphs(
        workspaceId,
        organisationId,
        id,
        height,
        width,
        token,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Quad Gate
     * @param {string} organisationId organisation Id
     * @param {string} id file Id
     * @param {number} coordX
     * @param {number} coordY
     * @param {number} paramX
     * @param {number} paramY
     * @param {string} parent
     * @param {string} yScale
     * @param {string} xScale
     * @param {number} width
     * @param {number} height
     * @param {string} token token is passed in header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    quadGate(
      organisationId: string,
      id: string,
      coordX: number,
      coordY: number,
      paramX: number,
      paramY: number,
      parent: string,
      yScale: string,
      xScale: string,
      width: number,
      height: number,
      token: string,
      options?: any
    ) {
      return GraphsGatesApiFp(configuration).quadGate(
        organisationId,
        id,
        coordX,
        coordY,
        paramX,
        paramY,
        parent,
        yScale,
        xScale,
        width,
        height,
        token,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Setting Gate
     * @param {string} workspaceId Workspace Id
     * @param {string} organisationId organisation Id
     * @param {string} id file Id
     * @param {string} gateNameUser
     * @param {GatingCoords} gatingCoords
     * @param {number} paramX
     * @param {number} paramY
     * @param {string} parent
     * @param {string} yScale
     * @param {string} xScale
     * @param {number} width
     * @param {number} height
     * @param {string} token token is passed in header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setGate(
      workspaceId: string,
      organisationId: string,
      id: string,
      gateNameUser: string,
      gatingCoords: GatingCoords,
      paramX: number,
      paramY: number,
      parent: string,
      yScale: string,
      xScale: string,
      width: number,
      height: number,
      token: string,
      options?: any
    ) {
      return GraphsGatesApiFp(configuration).setGate(
        workspaceId,
        organisationId,
        id,
        gateNameUser,
        gatingCoords,
        paramX,
        paramY,
        parent,
        yScale,
        xScale,
        width,
        height,
        token,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Create graph
     * @param {string} token Generate token and pass it in header
     * @param {any} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setGraph(token: string, body?: any, options?: any) {
      return GraphsGatesApiFp(configuration).setGraph(
        token,
        body,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Getting Statistics
     * @param {string} organisationId Organisation Id of logged in user
     * @param {string} selectedGate Selected Gate
     * @param {string} id File Id
     * @param {string} token token is passed in header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    statistics(
      organisationId: string,
      selectedGate: string,
      id: string,
      token: string,
      options?: any
    ) {
      return GraphsGatesApiFp(configuration).statistics(
        organisationId,
        selectedGate,
        id,
        token,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Update graph
     * @param {string} token Generate token and pass it in header
     * @param {Body5} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGraph(token: string, body?: Body5, options?: any) {
      return GraphsGatesApiFp(configuration).updateGraph(
        token,
        body,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * GraphsGatesApi - object-oriented interface
 * @export
 * @class GraphsGatesApi
 * @extends {BaseAPI}
 */
export class GraphsGatesApi extends BaseAPI {
  /**
   *
   * @summary Delete graph
   * @param {string} token Generate token and pass it in header
   * @param {Body6} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphsGatesApi
   */
  public deleteGraph(token: string, body?: Body6, options?: any) {
    return GraphsGatesApiFp(this.configuration).deleteGraph(
      token,
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Getting File Info
   * @param {string} organisationId Organisation Id of logged in user
   * @param {string} workspaceId Workspace Id
   * @param {string} id File Id
   * @param {string} token token is passed in header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphsGatesApi
   */
  public fileInfo(
    organisationId: string,
    workspaceId: string,
    id: string,
    token: string,
    options?: any
  ) {
    return GraphsGatesApiFp(this.configuration).fileInfo(
      organisationId,
      workspaceId,
      id,
      token,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Getting Canvas
   * @param {string} workspaceId Workspace Id
   * @param {string} organisationId Organisation Id
   * @param {string} fileIds File Id
   * @param {string} currentFileId File Id
   * @param {number} height Height of Graph
   * @param {number} width width of Graph
   * @param {string} paramX
   * @param {string} paramY
   * @param {string} selectedGate
   * @param {string} xScale
   * @param {string} yScale
   * @param {string} token token is passed in header
   * @param {string} [chartType]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphsGatesApi
   */
  public getCanvas(
    workspaceId: string,
    organisationId: string,
    fileIds: string,
    currentFileId: string,
    height: number,
    width: number,
    paramX: string,
    paramY: string,
    selectedGate: string,
    xScale: string,
    yScale: string,
    token: string,
    chartType?: string,
    options?: any
  ) {
    return GraphsGatesApiFp(this.configuration).getCanvas(
      workspaceId,
      organisationId,
      fileIds,
      currentFileId,
      height,
      width,
      paramX,
      paramY,
      selectedGate,
      xScale,
      yScale,
      token,
      chartType,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Getting Gates
   * @param {string} workspaceId Workspace Id
   * @param {string} token token is passed in header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphsGatesApi
   */
  public getGates(workspaceId: string, token: string, options?: any) {
    return GraphsGatesApiFp(this.configuration).getGates(
      workspaceId,
      token,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Getting Graphs
   * @param {string} workspaceId Workspace Id
   * @param {string} organisationId Organisation Id
   * @param {string} id File Id
   * @param {number} height Height of Graph
   * @param {number} width width of Graph
   * @param {string} token token is passed in header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphsGatesApi
   */
  public getGraphs(
    workspaceId: string,
    organisationId: string,
    id: string,
    height: number,
    width: number,
    token: string,
    options?: any
  ) {
    return GraphsGatesApiFp(this.configuration).getGraphs(
      workspaceId,
      organisationId,
      id,
      height,
      width,
      token,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Quad Gate
   * @param {string} organisationId organisation Id
   * @param {string} id file Id
   * @param {number} coordX
   * @param {number} coordY
   * @param {number} paramX
   * @param {number} paramY
   * @param {string} parent
   * @param {string} yScale
   * @param {string} xScale
   * @param {number} width
   * @param {number} height
   * @param {string} token token is passed in header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphsGatesApi
   */
  public quadGate(
    organisationId: string,
    id: string,
    coordX: number,
    coordY: number,
    paramX: number,
    paramY: number,
    parent: string,
    yScale: string,
    xScale: string,
    width: number,
    height: number,
    token: string,
    options?: any
  ) {
    return GraphsGatesApiFp(this.configuration).quadGate(
      organisationId,
      id,
      coordX,
      coordY,
      paramX,
      paramY,
      parent,
      yScale,
      xScale,
      width,
      height,
      token,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Setting Gate
   * @param {string} workspaceId Workspace Id
   * @param {string} organisationId organisation Id
   * @param {string} id file Id
   * @param {string} gateNameUser
   * @param {GatingCoords} gatingCoords
   * @param {number} paramX
   * @param {number} paramY
   * @param {string} parent
   * @param {string} yScale
   * @param {string} xScale
   * @param {number} width
   * @param {number} height
   * @param {string} token token is passed in header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphsGatesApi
   */
  public setGate(
    workspaceId: string,
    organisationId: string,
    id: string,
    gateNameUser: string,
    gatingCoords: GatingCoords,
    paramX: number,
    paramY: number,
    parent: string,
    yScale: string,
    xScale: string,
    width: number,
    height: number,
    token: string,
    options?: any
  ) {
    return GraphsGatesApiFp(this.configuration).setGate(
      workspaceId,
      organisationId,
      id,
      gateNameUser,
      gatingCoords,
      paramX,
      paramY,
      parent,
      yScale,
      xScale,
      width,
      height,
      token,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Create graph
   * @param {string} token Generate token and pass it in header
   * @param {any} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphsGatesApi
   */
  public setGraph(token: string, body?: any, options?: any) {
    return GraphsGatesApiFp(this.configuration).setGraph(
      token,
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Getting Statistics
   * @param {string} organisationId Organisation Id of logged in user
   * @param {string} selectedGate Selected Gate
   * @param {string} id File Id
   * @param {string} token token is passed in header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphsGatesApi
   */
  public statistics(
    organisationId: string,
    selectedGate: string,
    id: string,
    token: string,
    options?: any
  ) {
    return GraphsGatesApiFp(this.configuration).statistics(
      organisationId,
      selectedGate,
      id,
      token,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Update graph
   * @param {string} token Generate token and pass it in header
   * @param {Body5} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphsGatesApi
   */
  public updateGraph(token: string, body?: Body5, options?: any) {
    return GraphsGatesApiFp(this.configuration).updateGraph(
      token,
      body,
      options
    )(this.fetch, this.basePath);
  }
}
/**
 * UserApi - fetch parameter creator
 * @export
 */
export const UserApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Recieving Feedback from user
     * @summary Feedback
     * @param {string} token token is passed in header
     * @param {Body2} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    feedback(token: string, body?: Body2, options: any = {}): FetchArgs {
      // verify required parameter 'token' is not null or undefined
      if (token === null || token === undefined) {
        throw new RequiredError(
          "token",
          "Required parameter token was null or undefined when calling feedback."
        );
      }
      const localVarPath = `/api/feedback`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (token !== undefined && token !== null) {
        localVarHeaderParameter["token"] = String(token);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"Body2" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary My Account
     * @param {string} token token is passed in header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccount(token: string, options: any = {}): FetchArgs {
      // verify required parameter 'token' is not null or undefined
      if (token === null || token === undefined) {
        throw new RequiredError(
          "token",
          "Required parameter token was null or undefined when calling getAccount."
        );
      }
      const localVarPath = `/api/account`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (token !== undefined && token !== null) {
        localVarHeaderParameter["token"] = String(token);
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update User Account
     * @param {string} token token is passed in header
     * @param {any} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAccount(token: string, body?: any, options: any = {}): FetchArgs {
      // verify required parameter 'token' is not null or undefined
      if (token === null || token === undefined) {
        throw new RequiredError(
          "token",
          "Required parameter token was null or undefined when calling updateAccount."
        );
      }
      const localVarPath = `/api/updateaccount`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (token !== undefined && token !== null) {
        localVarHeaderParameter["token"] = String(token);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"any" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Getting User Order
     * @param {string} token token is passed in header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userexpertorders(token: string, options: any = {}): FetchArgs {
      // verify required parameter 'token' is not null or undefined
      if (token === null || token === undefined) {
        throw new RequiredError(
          "token",
          "Required parameter token was null or undefined when calling userexpertorders."
        );
      }
      const localVarPath = `/api/userexpertorders`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (token !== undefined && token !== null) {
        localVarHeaderParameter["token"] = String(token);
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Recieving Feedback from user
     * @summary Feedback
     * @param {string} token token is passed in header
     * @param {Body2} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    feedback(
      token: string,
      body?: Body2,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = UserApiFetchParamCreator(
        configuration
      ).feedback(token, body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary My Account
     * @param {string} token token is passed in header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccount(
      token: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = UserApiFetchParamCreator(
        configuration
      ).getAccount(token, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Update User Account
     * @param {string} token token is passed in header
     * @param {any} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAccount(
      token: string,
      body?: any,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
      const localVarFetchArgs = UserApiFetchParamCreator(
        configuration
      ).updateAccount(token, body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Getting User Order
     * @param {string} token token is passed in header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userexpertorders(
      token: string,
      options?: any
      //@ts-ignore
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ModelObject>> {
      const localVarFetchArgs = UserApiFetchParamCreator(
        configuration
      ).userexpertorders(token, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     * Recieving Feedback from user
     * @summary Feedback
     * @param {string} token token is passed in header
     * @param {Body2} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    feedback(token: string, body?: Body2, options?: any) {
      return UserApiFp(configuration).feedback(
        token,
        body,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary My Account
     * @param {string} token token is passed in header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccount(token: string, options?: any) {
      return UserApiFp(configuration).getAccount(token, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Update User Account
     * @param {string} token token is passed in header
     * @param {any} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAccount(token: string, body?: any, options?: any) {
      return UserApiFp(configuration).updateAccount(
        token,
        body,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Getting User Order
     * @param {string} token token is passed in header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userexpertorders(token: string, options?: any) {
      return UserApiFp(configuration).userexpertorders(token, options)(
        fetch,
        basePath
      );
    },
  };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
  /**
   * Recieving Feedback from user
   * @summary Feedback
   * @param {string} token token is passed in header
   * @param {Body2} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public feedback(token: string, body?: Body2, options?: any) {
    return UserApiFp(this.configuration).feedback(
      token,
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary My Account
   * @param {string} token token is passed in header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public getAccount(token: string, options?: any) {
    return UserApiFp(this.configuration).getAccount(token, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Update User Account
   * @param {string} token token is passed in header
   * @param {any} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public updateAccount(token: string, body?: any, options?: any) {
    return UserApiFp(this.configuration).updateAccount(
      token,
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Getting User Order
   * @param {string} token token is passed in header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public userexpertorders(token: string, options?: any) {
    return UserApiFp(this.configuration).userexpertorders(token, options)(
      this.fetch,
      this.basePath
    );
  }
}
/**
 * ExperimentFilesApi - fetch parameter creator
 * @export
 */
export const ExperimentFilesApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * To delete experiment file, we need to pass experimentId and fileId as query parameters
     * @summary Deleting Experiment File
     * @param {string} experimentId WxperimentId
     * @param {string} fileId File Id
     * @param {string} token Generate token and pass it in header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFile(
      experimentId: string,
      fileId: string,
      token: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'experimentId' is not null or undefined
      if (experimentId === null || experimentId === undefined) {
        throw new RequiredError(
          "experimentId",
          "Required parameter experimentId was null or undefined when calling deleteFile."
        );
      }
      // verify required parameter 'fileId' is not null or undefined
      if (fileId === null || fileId === undefined) {
        throw new RequiredError(
          "fileId",
          "Required parameter fileId was null or undefined when calling deleteFile."
        );
      }
      // verify required parameter 'token' is not null or undefined
      if (token === null || token === undefined) {
        throw new RequiredError(
          "token",
          "Required parameter token was null or undefined when calling deleteFile."
        );
      }
      const localVarPath = `/api/files/delete`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: "DELETE" },
        options
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (experimentId !== undefined) {
        localVarQueryParameter["experimentId"] = experimentId;
      }

      if (fileId !== undefined) {
        localVarQueryParameter["fileId"] = fileId;
      }

      if (token !== undefined && token !== null) {
        localVarHeaderParameter["token"] = String(token);
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * To edit experiment file, we need to pass experimentId, fileId and label as query parameters
     * @summary Editing Experiment File
     * @param {string} experimentId experimentId
     * @param {string} fileId File Id
     * @param {string} label Edited File Label
     * @param {string} token Generate token and pass it in header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editFiles(
      experimentId: string,
      fileId: string,
      label: string,
      token: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'experimentId' is not null or undefined
      if (experimentId === null || experimentId === undefined) {
        throw new RequiredError(
          "experimentId",
          "Required parameter experimentId was null or undefined when calling editFiles."
        );
      }
      // verify required parameter 'fileId' is not null or undefined
      if (fileId === null || fileId === undefined) {
        throw new RequiredError(
          "fileId",
          "Required parameter fileId was null or undefined when calling editFiles."
        );
      }
      // verify required parameter 'label' is not null or undefined
      if (label === null || label === undefined) {
        throw new RequiredError(
          "label",
          "Required parameter label was null or undefined when calling editFiles."
        );
      }
      // verify required parameter 'token' is not null or undefined
      if (token === null || token === undefined) {
        throw new RequiredError(
          "token",
          "Required parameter token was null or undefined when calling editFiles."
        );
      }
      const localVarPath = `/api/file/edit`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "PUT" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (experimentId !== undefined) {
        localVarQueryParameter["experimentId"] = experimentId;
      }

      if (fileId !== undefined) {
        localVarQueryParameter["fileId"] = fileId;
      }

      if (label !== undefined) {
        localVarQueryParameter["label"] = label;
      }

      if (token !== undefined && token !== null) {
        localVarHeaderParameter["token"] = String(token);
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * To uplaod fcs file we need to pass organisationId and experimentId in form data
     * @summary Upload fcs file
     * @param {string} token token is passed in header
     * @param {string} [experimentId]
     * @param {string} [organisationId]
     * @param {Blob} [file0]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadFile(
      token: string,
      experimentId?: string,
      organisationId?: string,
      file0?: Blob,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'token' is not null or undefined
      if (token === null || token === undefined) {
        throw new RequiredError(
          "token",
          "Required parameter token was null or undefined when calling uploadFile."
        );
      }
      const localVarPath = `/api/upload`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new url.URLSearchParams();

      if (token !== undefined && token !== null) {
        localVarHeaderParameter["token"] = String(token);
      }

      if (experimentId !== undefined) {
        localVarFormParams.set("experimentId", experimentId as any);
      }

      if (organisationId !== undefined) {
        localVarFormParams.set("organisationId", organisationId as any);
      }

      if (file0 !== undefined) {
        localVarFormParams.set("file[0]", file0 as any);
      }

      localVarHeaderParameter["Content-Type"] =
        "application/x-www-form-urlencoded";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      localVarRequestOptions.body = localVarFormParams.toString();

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * To get experiment files, we need to pass organisationId and experimentId in query params
     * @summary Getting Experiment Files
     * @param {string} organisationId Organisation Id of logged in user
     * @param {string} experimentId Experiment Id
     * @param {string} token token is passed in header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    experimentFiles(
      organisationId: string,
      experimentId: string,
      token: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'organisationId' is not null or undefined
      if (organisationId === null || organisationId === undefined) {
        throw new RequiredError(
          "organisationId",
          "Required parameter organisationId was null or undefined when calling experimentFiles."
        );
      }
      // verify required parameter 'experimentId' is not null or undefined
      if (experimentId === null || experimentId === undefined) {
        throw new RequiredError(
          "experimentId",
          "Required parameter experimentId was null or undefined when calling experimentFiles."
        );
      }
      // verify required parameter 'token' is not null or undefined
      if (token === null || token === undefined) {
        throw new RequiredError(
          "token",
          "Required parameter token was null or undefined when calling experimentFiles."
        );
      }
      const localVarPath = `/api/files`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (organisationId !== undefined) {
        localVarQueryParameter["organisationId"] = organisationId;
      }

      if (experimentId !== undefined) {
        localVarQueryParameter["experimentId"] = experimentId;
      }

      if (token !== undefined && token !== null) {
        localVarHeaderParameter["token"] = String(token);
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ExperimentFilesApi - functional programming interface
 * @export
 */
export const ExperimentFilesApiFp = function (configuration?: Configuration) {
  return {
    /**
     * To delete experiment file, we need to pass experimentId and fileId as query parameters
     * @summary Deleting experiment File
     * @param {string} experimentId ExperimentId
     * @param {string} fileId File Id
     * @param {string} token Generate token and pass it in header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFile(
      experimentId: string,
      fileId: string,
      token: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2005> {
      const localVarFetchArgs = ExperimentFilesApiFetchParamCreator(
        configuration
      ).deleteFile(experimentId, fileId, token, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * To edit experiment file, we need to pass experimentId, fileId and label as query parameters
     * @summary Editing Experiment File
     * @param {string} experimentId ExperimentId
     * @param {string} fileId File Id
     * @param {string} label Edited File Label
     * @param {string} token Generate token and pass it in header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editFiles(
      experimentId: string,
      fileId: string,
      label: string,
      token: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2005> {
      const localVarFetchArgs = ExperimentFilesApiFetchParamCreator(
        configuration
      ).editFiles(experimentId, fileId, label, token, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * To uplaod fcs file we need to pass organisationId and experimentId in form data
     * @summary Upload fcs file
     * @param {string} token token is passed in header
     * @param {string} [experimentId]
     * @param {string} [organisationId]
     * @param {Blob} [file0]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadFile(
      token: string,
      experimentId?: string,
      organisationId?: string,
      file0?: Blob,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2005> {
      const localVarFetchArgs = ExperimentFilesApiFetchParamCreator(
        configuration
      ).uploadFile(token, experimentId, organisationId, file0, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * To get experiment files, we need to pass organisationId and experimentId in query params
     * @summary Getting Experiment Files
     * @param {string} organisationId Organisation Id of logged in user
     * @param {string} experimentId Experiment Id
     * @param {string} token token is passed in header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    experimentFiles(
      organisationId: string,
      experimentId: string,
      token: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2008> {
      const localVarFetchArgs = ExperimentFilesApiFetchParamCreator(
        configuration
      ).experimentFiles(organisationId, experimentId, token, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * ExperimentFilesApi - factory interface
 * @export
 */
export const ExperimentFilesApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     * To delete experiment file, we need to pass experimentId and fileId as query parameters
     * @summary Deleting experiment File
     * @param {string} experimentId ExperimentId
     * @param {string} fileId File Id
     * @param {string} token Generate token and pass it in header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFile(
      experimentId: string,
      fileId: string,
      token: string,
      options?: any
    ) {
      return ExperimentFilesApiFp(configuration).deleteFile(
        experimentId,
        fileId,
        token,
        options
      )(fetch, basePath);
    },
    /**
     * To edit experiment file, we need to pass experimentId, fileId and label as query parameters
     * @summary Editing Experiment File
     * @param {string} experimentId ExperimentId
     * @param {string} fileId File Id
     * @param {string} label Edited File Label
     * @param {string} token Generate token and pass it in header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editFiles(
      experimentId: string,
      fileId: string,
      label: string,
      token: string,
      options?: any
    ) {
      return ExperimentFilesApiFp(configuration).editFiles(
        experimentId,
        fileId,
        label,
        token,
        options
      )(fetch, basePath);
    },
    /**
     * To uplaod fcs file we need to pass organisationId and experimentId in form data
     * @summary Upload fcs file
     * @param {string} token token is passed in header
     * @param {string} [experimentId]
     * @param {string} [organisationId]
     * @param {Blob} [file0]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadFile(
      token: string,
      experimentId?: string,
      organisationId?: string,
      file0?: Blob,
      options?: any
    ) {
      return ExperimentFilesApiFp(configuration).uploadFile(
        token,
        experimentId,
        organisationId,
        file0,
        options
      )(fetch, basePath);
    },
    /**
     * To get experiment files, we need to pass organisationId and experimentId in query params
     * @summary Getting Experiment Files
     * @param {string} organisationId Organisation Id of logged in user
     * @param {string} experimentId Experiment Id
     * @param {string} token token is passed in header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    experimentFiles(
      organisationId: string,
      experimentId: string,
      token: string,
      options?: any
    ) {
      return ExperimentFilesApiFp(configuration).experimentFiles(
        organisationId,
        experimentId,
        token,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * ExperimentFilesApi - object-oriented interface
 * @export
 * @class ExperimentFilesApi
 * @extends {BaseAPI}
 */
export class ExperimentFilesApi extends BaseAPI {
  /**
   * To delete experiment file, we need to pass experimentId and fileId as query parameters
   * @summary Deleting Experiment File
   * @param {string} experimentId ExperimentId
   * @param {string} fileId File Id
   * @param {string} token Generate token and pass it in header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExperimentFilesApi
   */
  public deleteFile(
    experimentId: string,
    fileId: string,
    token: string,
    options?: any
  ) {
    return ExperimentFilesApiFp(this.configuration).deleteFile(
      experimentId,
      fileId,
      token,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * To edit experiment file, we need to pass experimentId, fileId and label as query parameters
   * @summary Editing Experiment File
   * @param {string} experimentId ExperimentId
   * @param {string} fileId File Id
   * @param {string} label Edited File Label
   * @param {string} token Generate token and pass it in header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExperimenteFilesApi
   */
  public editFiles(
    experimentId: string,
    fileId: string,
    label: string,
    token: string,
    options?: any
  ) {
    return ExperimentFilesApiFp(this.configuration).editFiles(
      experimentId,
      fileId,
      label,
      token,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * To uplaod fcs file we need to pass organisationId and experimentId in form data
   * @summary Upload fcs file
   * @param {string} token token is passed in header
   * @param {string} [experimentId]
   * @param {string} [organisationId]
   * @param {Blob} [file0]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExperimentFilesApi
   */
  public uploadFile(
    token: string,
    experimentId?: string,
    organisationId?: string,
    file0?: Blob,
    options?: any
  ) {
    return ExperimentFilesApiFp(this.configuration).uploadFile(
      token,
      experimentId,
      organisationId,
      file0,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * To get experiment files, we need to pass organisationId and experimentId in query params
   * @summary Getting Experiment Files
   * @param {string} organisationId Organisation Id of logged in user
   * @param {string} experimentId Experiment Id
   * @param {string} token token is passed in header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExperimentFilesApi
   */
  public experimentFiles(
    organisationId: string,
    experimentId: string,
    token: string,
    options?: any
  ) {
    return ExperimentFilesApiFp(this.configuration).experimentFiles(
      organisationId,
      experimentId,
      token,
      options
    )(this.fetch, this.basePath);
  }
}
/**
 * WorkspacesApi - fetch parameter creator
 * @export
 */
export const WorkspacesApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * To create Workspace, we need to pass organisationId,workspace name and isPrivate in body of request
     * @summary Creating Workspaces
     * @param {string} token Generate token and pass it in header
     * @param {Body3} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    upsertWorkSpace(token: string, body?: any, options: any = {}): FetchArgs {
      // verify required parameter 'token' is not null or undefined
      if (token === null || token === undefined) {
        throw new RequiredError(
          "token",
          "Required parameter token was null or undefined when calling createWorkspace."
        );
      }
      const localVarPath = `/api/workspace`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (token !== undefined && token !== null) {
        localVarHeaderParameter["token"] = String(token);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"Body3" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * To get workspaces, OrganisationId is passed in params
     * @summary Getting Workspaces
     * @param {string} organisationId Organisation Id of logged in user
     * @param {string} token token is passed in header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    appWorkspace(
      organisationId: string,
      token: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'organisationId' is not null or undefined
      if (organisationId === null || organisationId === undefined) {
        throw new RequiredError(
          "organisationId",
          "Required parameter organisationId was null or undefined when calling appWorkspace."
        );
      }
      // verify required parameter 'token' is not null or undefined
      if (token === null || token === undefined) {
        throw new RequiredError(
          "token",
          "Required parameter token was null or undefined when calling appWorkspace."
        );
      }
      const localVarPath = `/api/workspaces`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (organisationId !== undefined) {
        localVarQueryParameter["organisationId"] = organisationId;
      }

      if (token !== undefined && token !== null) {
        localVarHeaderParameter["token"] = String(token);
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * To create Workspace, we need to pass organisationId,workspace name and isPrivate in body of request
     * @summary Creating Workspaces
     * @param {string} token Generate token and pass it in header
     * @param {Body3} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWorkspace(token: string, body?: Body3, options: any = {}): FetchArgs {
      // verify required parameter 'token' is not null or undefined
      if (token === null || token === undefined) {
        throw new RequiredError(
          "token",
          "Required parameter token was null or undefined when calling createWorkspace."
        );
      }
      const localVarPath = `/api/create/workspace`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (token !== undefined && token !== null) {
        localVarHeaderParameter["token"] = String(token);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"Body3" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * To delete workspace, we need to pass workspaceId and workspaceName as query parameters
     * @summary Deleting Workspaces
     * @param {string} workspaceId WorkspaceId
     * @param {string} token Generate token and pass it in header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteWorkspace(
      workspaceId: string,
      token: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'workspaceId' is not null or undefined
      if (workspaceId === null || workspaceId === undefined) {
        throw new RequiredError(
          "workspaceId",
          "Required parameter workspaceId was null or undefined when calling deleteWorkspace."
        );
      }
      // verify required parameter 'token' is not null or undefined
      if (token === null || token === undefined) {
        throw new RequiredError(
          "token",
          "Required parameter token was null or undefined when calling deleteWorkspace."
        );
      }
      const localVarPath = `/api/workspace/delete`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: "DELETE" },
        options
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (workspaceId !== undefined) {
        localVarQueryParameter["workspaceId"] = workspaceId;
      }

      if (token !== undefined && token !== null) {
        localVarHeaderParameter["token"] = String(token);
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * To edit workspace, we need to pass workspaceId and workspaceName as query parameters
     * @summary Editing Workspaces
     * @param {string} workspaceId WorkspaceId
     * @param {string} workspaceName workspaceName
     * @param {string} token Generate token and pass it in header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editWorkspace(
      workspaceId: string,
      workspaceName: string,
      token: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'workspaceId' is not null or undefined
      if (workspaceId === null || workspaceId === undefined) {
        throw new RequiredError(
          "workspaceId",
          "Required parameter workspaceId was null or undefined when calling editWorkspace."
        );
      }
      // verify required parameter 'workspaceName' is not null or undefined
      if (workspaceName === null || workspaceName === undefined) {
        throw new RequiredError(
          "workspaceName",
          "Required parameter workspaceName was null or undefined when calling editWorkspace."
        );
      }
      // verify required parameter 'token' is not null or undefined
      if (token === null || token === undefined) {
        throw new RequiredError(
          "token",
          "Required parameter token was null or undefined when calling editWorkspace."
        );
      }
      const localVarPath = `/api/workspace/edit`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "PUT" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (workspaceId !== undefined) {
        localVarQueryParameter["workspaceId"] = workspaceId;
      }

      if (workspaceName !== undefined) {
        localVarQueryParameter["workspaceName"] = workspaceName;
      }

      if (token !== undefined && token !== null) {
        localVarHeaderParameter["token"] = String(token);
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * WorkspacesApi - functional programming interface
 * @export
 */
export const WorkspacesApiFp = function (configuration?: Configuration) {
  return {
    /**
     * To get workspaces, OrganisationId is passed in params
     * @summary Getting Workspaces
     * @param {string} organisationId Organisation Id of logged in user
     * @param {string} token token is passed in header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    appWorkspace(
      organisationId: string,
      token: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
      const localVarFetchArgs = WorkspacesApiFetchParamCreator(
        configuration
      ).appWorkspace(organisationId, token, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * To create Workspace, we need to pass organisationId,workspace name and isPrivate in body of request
     * @summary Creating Workspaces
     * @param {string} token Generate token and pass it in header
     * @param {Body3} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWorkspace(
      token: string,
      body?: Body3,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
      const localVarFetchArgs = WorkspacesApiFetchParamCreator(
        configuration
      ).createWorkspace(token, body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * To delete workspace, we need to pass workspaceId and workspaceName as query parameters
     * @summary Deleting Workspaces
     * @param {string} workspaceId WorkspaceId
     * @param {string} token Generate token and pass it in header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteWorkspace(
      workspaceId: string,
      token: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2005> {
      const localVarFetchArgs = WorkspacesApiFetchParamCreator(
        configuration
      ).deleteWorkspace(workspaceId, token, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * To edit workspace, we need to pass workspaceId and workspaceName as query parameters
     * @summary Editing Workspaces
     * @param {string} workspaceId WorkspaceId
     * @param {string} workspaceName workspaceName
     * @param {string} token Generate token and pass it in header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editWorkspace(
      workspaceId: string,
      workspaceName: string,
      token: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2005> {
      const localVarFetchArgs = WorkspacesApiFetchParamCreator(
        configuration
      ).editWorkspace(workspaceId, workspaceName, token, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * WorkspacesApi - factory interface
 * @export
 */
export const WorkspacesApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     * To get workspaces, OrganisationId is passed in params
     * @summary Getting Workspaces
     * @param {string} organisationId Organisation Id of logged in user
     * @param {string} token token is passed in header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    appWorkspace(organisationId: string, token: string, options?: any) {
      return WorkspacesApiFp(configuration).appWorkspace(
        organisationId,
        token,
        options
      )(fetch, basePath);
    },
    /**
     * To create Workspace, we need to pass organisationId,workspace name and isPrivate in body of request
     * @summary Creating Workspaces
     * @param {string} token Generate token and pass it in header
     * @param {Body3} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWorkspace(token: string, body?: Body3, options?: any) {
      return WorkspacesApiFp(configuration).createWorkspace(
        token,
        body,
        options
      )(fetch, basePath);
    },
    /**
     * To delete workspace, we need to pass workspaceId and workspaceName as query parameters
     * @summary Deleting Workspaces
     * @param {string} workspaceId WorkspaceId
     * @param {string} token Generate token and pass it in header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteWorkspace(workspaceId: string, token: string, options?: any) {
      return WorkspacesApiFp(configuration).deleteWorkspace(
        workspaceId,
        token,
        options
      )(fetch, basePath);
    },
    /**
     * To edit workspace, we need to pass workspaceId and workspaceName as query parameters
     * @summary Editing Workspaces
     * @param {string} workspaceId WorkspaceId
     * @param {string} workspaceName workspaceName
     * @param {string} token Generate token and pass it in header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editWorkspace(
      workspaceId: string,
      workspaceName: string,
      token: string,
      options?: any
    ) {
      return WorkspacesApiFp(configuration).editWorkspace(
        workspaceId,
        workspaceName,
        token,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * WorkspacesApi - object-oriented interface
 * @export
 * @class WorkspacesApi
 * @extends {BaseAPI}
 */
export class WorkspacesApi extends BaseAPI {
  /**
   * To get workspaces, OrganisationId is passed in params
   * @summary Getting Workspaces
   * @param {string} organisationId Organisation Id of logged in user
   * @param {string} token token is passed in header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WorkspacesApi
   */
  public appWorkspace(organisationId: string, token: string, options?: any) {
    return WorkspacesApiFp(this.configuration).appWorkspace(
      organisationId,
      token,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * To create Workspace, we need to pass organisationId,workspace name and isPrivate in body of request
   * @summary Creating Workspaces
   * @param {string} token Generate token and pass it in header
   * @param {Body3} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WorkspacesApi
   */
  public createWorkspace(token: string, body?: Body3, options?: any) {
    return WorkspacesApiFp(this.configuration).createWorkspace(
      token,
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * To delete workspace, we need to pass workspaceId and workspaceName as query parameters
   * @summary Deleting Workspaces
   * @param {string} workspaceId WorkspaceId
   * @param {string} token Generate token and pass it in header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WorkspacesApi
   */
  public deleteWorkspace(workspaceId: string, token: string, options?: any) {
    return WorkspacesApiFp(this.configuration).deleteWorkspace(
      workspaceId,
      token,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * To edit workspace, we need to pass workspaceId and workspaceName as query parameters
   * @summary Editing Workspaces
   * @param {string} workspaceId WorkspaceId
   * @param {string} workspaceName workspaceName
   * @param {string} token Generate token and pass it in header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WorkspacesApi
   */
  public editWorkspace(
    workspaceId: string,
    workspaceName: string,
    token: string,
    options?: any
  ) {
    return WorkspacesApiFp(this.configuration).editWorkspace(
      workspaceId,
      workspaceName,
      token,
      options
    )(this.fetch, this.basePath);
  }
}
