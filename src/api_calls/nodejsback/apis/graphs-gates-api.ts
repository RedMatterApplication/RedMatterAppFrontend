/* tslint:disable */
/* eslint-disable */
/**
 * Red Matter
 * API configuration
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { Body5 } from '../models';
import { Body6 } from '../models';
import { GatingCoords } from '../models';
import { InlineResponse20010 } from '../models';
import { InlineResponse20011 } from '../models';
import { InlineResponse20012 } from '../models';
import { InlineResponse2005 } from '../models';
import { InlineResponse2009 } from '../models';
import { InlineResponse4001 } from '../models';
/**
 * GraphsGatesApi - axios parameter creator
 * @export
 */
export const GraphsGatesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete graph
         * @param {string} token Generate token and pass it in header
         * @param {Body6} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGraph: async (token: string, body?: Body6, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling deleteGraph.');
            }
            const localVarPath = `/api/delete/graph`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (token !== undefined && token !== null) {
                localVarHeaderParameter['token'] = String(token);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Getting File Info
         * @param {string} organisationId Organisation Id of logged in user
         * @param {string} workspaceId Workspace Id
         * @param {string} id File Id
         * @param {string} token token is passed in header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileInfo: async (organisationId: string, workspaceId: string, id: string, token: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling fileInfo.');
            }
            // verify required parameter 'workspaceId' is not null or undefined
            if (workspaceId === null || workspaceId === undefined) {
                throw new RequiredError('workspaceId','Required parameter workspaceId was null or undefined when calling fileInfo.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling fileInfo.');
            }
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling fileInfo.');
            }
            const localVarPath = `/api/canvas/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (organisationId !== undefined) {
                localVarQueryParameter['organisationId'] = organisationId;
            }

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspaceId'] = workspaceId;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (token !== undefined && token !== null) {
                localVarHeaderParameter['token'] = String(token);
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Getting Canvas
         * @param {string} workspaceId Workspace Id
         * @param {string} organisationId Organisation Id
         * @param {string} fileIds File Id
         * @param {string} currentFileId File Id
         * @param {number} height Height of Graph
         * @param {number} width width of Graph
         * @param {string} paramX 
         * @param {string} paramY 
         * @param {string} selectedGate 
         * @param {string} xScale 
         * @param {string} yScale 
         * @param {string} token token is passed in header
         * @param {string} [chartType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCanvas: async (workspaceId: string, organisationId: string, fileIds: string, currentFileId: string, height: number, width: number, paramX: string, paramY: string, selectedGate: string, xScale: string, yScale: string, token: string, chartType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            if (workspaceId === null || workspaceId === undefined) {
                throw new RequiredError('workspaceId','Required parameter workspaceId was null or undefined when calling getCanvas.');
            }
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling getCanvas.');
            }
            // verify required parameter 'fileIds' is not null or undefined
            if (fileIds === null || fileIds === undefined) {
                throw new RequiredError('fileIds','Required parameter fileIds was null or undefined when calling getCanvas.');
            }
            // verify required parameter 'currentFileId' is not null or undefined
            if (currentFileId === null || currentFileId === undefined) {
                throw new RequiredError('currentFileId','Required parameter currentFileId was null or undefined when calling getCanvas.');
            }
            // verify required parameter 'height' is not null or undefined
            if (height === null || height === undefined) {
                throw new RequiredError('height','Required parameter height was null or undefined when calling getCanvas.');
            }
            // verify required parameter 'width' is not null or undefined
            if (width === null || width === undefined) {
                throw new RequiredError('width','Required parameter width was null or undefined when calling getCanvas.');
            }
            // verify required parameter 'paramX' is not null or undefined
            if (paramX === null || paramX === undefined) {
                throw new RequiredError('paramX','Required parameter paramX was null or undefined when calling getCanvas.');
            }
            // verify required parameter 'paramY' is not null or undefined
            if (paramY === null || paramY === undefined) {
                throw new RequiredError('paramY','Required parameter paramY was null or undefined when calling getCanvas.');
            }
            // verify required parameter 'selectedGate' is not null or undefined
            if (selectedGate === null || selectedGate === undefined) {
                throw new RequiredError('selectedGate','Required parameter selectedGate was null or undefined when calling getCanvas.');
            }
            // verify required parameter 'xScale' is not null or undefined
            if (xScale === null || xScale === undefined) {
                throw new RequiredError('xScale','Required parameter xScale was null or undefined when calling getCanvas.');
            }
            // verify required parameter 'yScale' is not null or undefined
            if (yScale === null || yScale === undefined) {
                throw new RequiredError('yScale','Required parameter yScale was null or undefined when calling getCanvas.');
            }
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getCanvas.');
            }
            const localVarPath = `/api/canvas`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspaceId'] = workspaceId;
            }

            if (organisationId !== undefined) {
                localVarQueryParameter['organisationId'] = organisationId;
            }

            if (fileIds !== undefined) {
                localVarQueryParameter['fileIds'] = fileIds;
            }

            if (currentFileId !== undefined) {
                localVarQueryParameter['currentFileId'] = currentFileId;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (chartType !== undefined) {
                localVarQueryParameter['chartType'] = chartType;
            }

            if (paramX !== undefined) {
                localVarQueryParameter['paramX'] = paramX;
            }

            if (paramY !== undefined) {
                localVarQueryParameter['paramY'] = paramY;
            }

            if (selectedGate !== undefined) {
                localVarQueryParameter['selectedGate'] = selectedGate;
            }

            if (xScale !== undefined) {
                localVarQueryParameter['xScale'] = xScale;
            }

            if (yScale !== undefined) {
                localVarQueryParameter['yScale'] = yScale;
            }

            if (token !== undefined && token !== null) {
                localVarHeaderParameter['token'] = String(token);
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Getting Gates
         * @param {string} workspaceId Workspace Id
         * @param {string} token token is passed in header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGates: async (workspaceId: string, token: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            if (workspaceId === null || workspaceId === undefined) {
                throw new RequiredError('workspaceId','Required parameter workspaceId was null or undefined when calling getGates.');
            }
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getGates.');
            }
            const localVarPath = `/api/get/gates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspaceId'] = workspaceId;
            }

            if (token !== undefined && token !== null) {
                localVarHeaderParameter['token'] = String(token);
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Getting Graphs
         * @param {string} workspaceId Workspace Id
         * @param {string} organisationId Organisation Id
         * @param {string} id File Id
         * @param {number} height Height of Graph
         * @param {number} width width of Graph
         * @param {string} token token is passed in header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGraphs: async (workspaceId: string, organisationId: string, id: string, height: number, width: number, token: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            if (workspaceId === null || workspaceId === undefined) {
                throw new RequiredError('workspaceId','Required parameter workspaceId was null or undefined when calling getGraphs.');
            }
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling getGraphs.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getGraphs.');
            }
            // verify required parameter 'height' is not null or undefined
            if (height === null || height === undefined) {
                throw new RequiredError('height','Required parameter height was null or undefined when calling getGraphs.');
            }
            // verify required parameter 'width' is not null or undefined
            if (width === null || width === undefined) {
                throw new RequiredError('width','Required parameter width was null or undefined when calling getGraphs.');
            }
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getGraphs.');
            }
            const localVarPath = `/api/get/graphs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspaceId'] = workspaceId;
            }

            if (organisationId !== undefined) {
                localVarQueryParameter['organisationId'] = organisationId;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (token !== undefined && token !== null) {
                localVarHeaderParameter['token'] = String(token);
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Quad Gate
         * @param {string} organisationId organisation Id
         * @param {string} id file Id
         * @param {number} coordX 
         * @param {number} coordY 
         * @param {number} paramX 
         * @param {number} paramY 
         * @param {string} parent 
         * @param {string} yScale 
         * @param {string} xScale 
         * @param {number} width 
         * @param {number} height 
         * @param {string} token token is passed in header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quadGate: async (organisationId: string, id: string, coordX: number, coordY: number, paramX: number, paramY: number, parent: string, yScale: string, xScale: string, width: number, height: number, token: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling quadGate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling quadGate.');
            }
            // verify required parameter 'coordX' is not null or undefined
            if (coordX === null || coordX === undefined) {
                throw new RequiredError('coordX','Required parameter coordX was null or undefined when calling quadGate.');
            }
            // verify required parameter 'coordY' is not null or undefined
            if (coordY === null || coordY === undefined) {
                throw new RequiredError('coordY','Required parameter coordY was null or undefined when calling quadGate.');
            }
            // verify required parameter 'paramX' is not null or undefined
            if (paramX === null || paramX === undefined) {
                throw new RequiredError('paramX','Required parameter paramX was null or undefined when calling quadGate.');
            }
            // verify required parameter 'paramY' is not null or undefined
            if (paramY === null || paramY === undefined) {
                throw new RequiredError('paramY','Required parameter paramY was null or undefined when calling quadGate.');
            }
            // verify required parameter 'parent' is not null or undefined
            if (parent === null || parent === undefined) {
                throw new RequiredError('parent','Required parameter parent was null or undefined when calling quadGate.');
            }
            // verify required parameter 'yScale' is not null or undefined
            if (yScale === null || yScale === undefined) {
                throw new RequiredError('yScale','Required parameter yScale was null or undefined when calling quadGate.');
            }
            // verify required parameter 'xScale' is not null or undefined
            if (xScale === null || xScale === undefined) {
                throw new RequiredError('xScale','Required parameter xScale was null or undefined when calling quadGate.');
            }
            // verify required parameter 'width' is not null or undefined
            if (width === null || width === undefined) {
                throw new RequiredError('width','Required parameter width was null or undefined when calling quadGate.');
            }
            // verify required parameter 'height' is not null or undefined
            if (height === null || height === undefined) {
                throw new RequiredError('height','Required parameter height was null or undefined when calling quadGate.');
            }
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling quadGate.');
            }
            const localVarPath = `/api/set/quadgate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (organisationId !== undefined) {
                localVarQueryParameter['organisationId'] = organisationId;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (coordX !== undefined) {
                localVarQueryParameter['coordX'] = coordX;
            }

            if (coordY !== undefined) {
                localVarQueryParameter['coordY'] = coordY;
            }

            if (paramX !== undefined) {
                localVarQueryParameter['paramX'] = paramX;
            }

            if (paramY !== undefined) {
                localVarQueryParameter['paramY'] = paramY;
            }

            if (parent !== undefined) {
                localVarQueryParameter['parent'] = parent;
            }

            if (yScale !== undefined) {
                localVarQueryParameter['yScale'] = yScale;
            }

            if (xScale !== undefined) {
                localVarQueryParameter['xScale'] = xScale;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (token !== undefined && token !== null) {
                localVarHeaderParameter['token'] = String(token);
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Setting Gate
         * @param {string} workspaceId Workspace Id
         * @param {string} organisationId organisation Id
         * @param {string} id file Id
         * @param {string} gateNameUser 
         * @param {GatingCoords} gatingCoords 
         * @param {number} paramX 
         * @param {number} paramY 
         * @param {string} parent 
         * @param {string} yScale 
         * @param {string} xScale 
         * @param {number} width 
         * @param {number} height 
         * @param {string} token token is passed in header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setGate: async (workspaceId: string, organisationId: string, id: string, gateNameUser: string, gatingCoords: GatingCoords, paramX: number, paramY: number, parent: string, yScale: string, xScale: string, width: number, height: number, token: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            if (workspaceId === null || workspaceId === undefined) {
                throw new RequiredError('workspaceId','Required parameter workspaceId was null or undefined when calling setGate.');
            }
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling setGate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling setGate.');
            }
            // verify required parameter 'gateNameUser' is not null or undefined
            if (gateNameUser === null || gateNameUser === undefined) {
                throw new RequiredError('gateNameUser','Required parameter gateNameUser was null or undefined when calling setGate.');
            }
            // verify required parameter 'gatingCoords' is not null or undefined
            if (gatingCoords === null || gatingCoords === undefined) {
                throw new RequiredError('gatingCoords','Required parameter gatingCoords was null or undefined when calling setGate.');
            }
            // verify required parameter 'paramX' is not null or undefined
            if (paramX === null || paramX === undefined) {
                throw new RequiredError('paramX','Required parameter paramX was null or undefined when calling setGate.');
            }
            // verify required parameter 'paramY' is not null or undefined
            if (paramY === null || paramY === undefined) {
                throw new RequiredError('paramY','Required parameter paramY was null or undefined when calling setGate.');
            }
            // verify required parameter 'parent' is not null or undefined
            if (parent === null || parent === undefined) {
                throw new RequiredError('parent','Required parameter parent was null or undefined when calling setGate.');
            }
            // verify required parameter 'yScale' is not null or undefined
            if (yScale === null || yScale === undefined) {
                throw new RequiredError('yScale','Required parameter yScale was null or undefined when calling setGate.');
            }
            // verify required parameter 'xScale' is not null or undefined
            if (xScale === null || xScale === undefined) {
                throw new RequiredError('xScale','Required parameter xScale was null or undefined when calling setGate.');
            }
            // verify required parameter 'width' is not null or undefined
            if (width === null || width === undefined) {
                throw new RequiredError('width','Required parameter width was null or undefined when calling setGate.');
            }
            // verify required parameter 'height' is not null or undefined
            if (height === null || height === undefined) {
                throw new RequiredError('height','Required parameter height was null or undefined when calling setGate.');
            }
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling setGate.');
            }
            const localVarPath = `/api/set/gate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspaceId'] = workspaceId;
            }

            if (organisationId !== undefined) {
                localVarQueryParameter['organisationId'] = organisationId;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (gateNameUser !== undefined) {
                localVarQueryParameter['gateNameUser'] = gateNameUser;
            }

            if (gatingCoords !== undefined) {
                localVarQueryParameter['gatingCoords'] = gatingCoords;
            }

            if (paramX !== undefined) {
                localVarQueryParameter['paramX'] = paramX;
            }

            if (paramY !== undefined) {
                localVarQueryParameter['paramY'] = paramY;
            }

            if (parent !== undefined) {
                localVarQueryParameter['parent'] = parent;
            }

            if (yScale !== undefined) {
                localVarQueryParameter['yScale'] = yScale;
            }

            if (xScale !== undefined) {
                localVarQueryParameter['xScale'] = xScale;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (token !== undefined && token !== null) {
                localVarHeaderParameter['token'] = String(token);
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create graph
         * @param {string} token Generate token and pass it in header
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setGraph: async (token: string, body?: any, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling setGraph.');
            }
            const localVarPath = `/api/set/graph`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (token !== undefined && token !== null) {
                localVarHeaderParameter['token'] = String(token);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Getting Statistics
         * @param {string} organisationId Organisation Id of logged in user
         * @param {string} selectedGate Selected Gate
         * @param {string} id File Id
         * @param {string} token token is passed in header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statistics: async (organisationId: string, selectedGate: string, id: string, token: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling statistics.');
            }
            // verify required parameter 'selectedGate' is not null or undefined
            if (selectedGate === null || selectedGate === undefined) {
                throw new RequiredError('selectedGate','Required parameter selectedGate was null or undefined when calling statistics.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling statistics.');
            }
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling statistics.');
            }
            const localVarPath = `/api/get/statistics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (organisationId !== undefined) {
                localVarQueryParameter['organisationId'] = organisationId;
            }

            if (selectedGate !== undefined) {
                localVarQueryParameter['selectedGate'] = selectedGate;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (token !== undefined && token !== null) {
                localVarHeaderParameter['token'] = String(token);
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update graph
         * @param {string} token Generate token and pass it in header
         * @param {Body5} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGraph: async (token: string, body?: Body5, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling updateGraph.');
            }
            const localVarPath = `/api/update/graph`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (token !== undefined && token !== null) {
                localVarHeaderParameter['token'] = String(token);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GraphsGatesApi - functional programming interface
 * @export
 */
export const GraphsGatesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete graph
         * @param {string} token Generate token and pass it in header
         * @param {Body6} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGraph(token: string, body?: Body6, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2005>> {
            const localVarAxiosArgs = await GraphsGatesApiAxiosParamCreator(configuration).deleteGraph(token, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Getting File Info
         * @param {string} organisationId Organisation Id of logged in user
         * @param {string} workspaceId Workspace Id
         * @param {string} id File Id
         * @param {string} token token is passed in header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fileInfo(organisationId: string, workspaceId: string, id: string, token: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2009>> {
            const localVarAxiosArgs = await GraphsGatesApiAxiosParamCreator(configuration).fileInfo(organisationId, workspaceId, id, token, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Getting Canvas
         * @param {string} workspaceId Workspace Id
         * @param {string} organisationId Organisation Id
         * @param {string} fileIds File Id
         * @param {string} currentFileId File Id
         * @param {number} height Height of Graph
         * @param {number} width width of Graph
         * @param {string} paramX 
         * @param {string} paramY 
         * @param {string} selectedGate 
         * @param {string} xScale 
         * @param {string} yScale 
         * @param {string} token token is passed in header
         * @param {string} [chartType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCanvas(workspaceId: string, organisationId: string, fileIds: string, currentFileId: string, height: number, width: number, paramX: string, paramY: string, selectedGate: string, xScale: string, yScale: string, token: string, chartType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await GraphsGatesApiAxiosParamCreator(configuration).getCanvas(workspaceId, organisationId, fileIds, currentFileId, height, width, paramX, paramY, selectedGate, xScale, yScale, token, chartType, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Getting Gates
         * @param {string} workspaceId Workspace Id
         * @param {string} token token is passed in header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGates(workspaceId: string, token: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<any>>> {
            const localVarAxiosArgs = await GraphsGatesApiAxiosParamCreator(configuration).getGates(workspaceId, token, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Getting Graphs
         * @param {string} workspaceId Workspace Id
         * @param {string} organisationId Organisation Id
         * @param {string} id File Id
         * @param {number} height Height of Graph
         * @param {number} width width of Graph
         * @param {string} token token is passed in header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGraphs(workspaceId: string, organisationId: string, id: string, height: number, width: number, token: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse20011>>> {
            const localVarAxiosArgs = await GraphsGatesApiAxiosParamCreator(configuration).getGraphs(workspaceId, organisationId, id, height, width, token, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Quad Gate
         * @param {string} organisationId organisation Id
         * @param {string} id file Id
         * @param {number} coordX 
         * @param {number} coordY 
         * @param {number} paramX 
         * @param {number} paramY 
         * @param {string} parent 
         * @param {string} yScale 
         * @param {string} xScale 
         * @param {number} width 
         * @param {number} height 
         * @param {string} token token is passed in header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async quadGate(organisationId: string, id: string, coordX: number, coordY: number, paramX: number, paramY: number, parent: string, yScale: string, xScale: string, width: number, height: number, token: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20012>> {
            const localVarAxiosArgs = await GraphsGatesApiAxiosParamCreator(configuration).quadGate(organisationId, id, coordX, coordY, paramX, paramY, parent, yScale, xScale, width, height, token, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Setting Gate
         * @param {string} workspaceId Workspace Id
         * @param {string} organisationId organisation Id
         * @param {string} id file Id
         * @param {string} gateNameUser 
         * @param {GatingCoords} gatingCoords 
         * @param {number} paramX 
         * @param {number} paramY 
         * @param {string} parent 
         * @param {string} yScale 
         * @param {string} xScale 
         * @param {number} width 
         * @param {number} height 
         * @param {string} token token is passed in header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setGate(workspaceId: string, organisationId: string, id: string, gateNameUser: string, gatingCoords: GatingCoords, paramX: number, paramY: number, parent: string, yScale: string, xScale: string, width: number, height: number, token: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<any>>> {
            const localVarAxiosArgs = await GraphsGatesApiAxiosParamCreator(configuration).setGate(workspaceId, organisationId, id, gateNameUser, gatingCoords, paramX, paramY, parent, yScale, xScale, width, height, token, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Create graph
         * @param {string} token Generate token and pass it in header
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setGraph(token: string, body?: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<any>>> {
            const localVarAxiosArgs = await GraphsGatesApiAxiosParamCreator(configuration).setGraph(token, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Getting Statistics
         * @param {string} organisationId Organisation Id of logged in user
         * @param {string} selectedGate Selected Gate
         * @param {string} id File Id
         * @param {string} token token is passed in header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statistics(organisationId: string, selectedGate: string, id: string, token: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20010>> {
            const localVarAxiosArgs = await GraphsGatesApiAxiosParamCreator(configuration).statistics(organisationId, selectedGate, id, token, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Update graph
         * @param {string} token Generate token and pass it in header
         * @param {Body5} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGraph(token: string, body?: Body5, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2005>> {
            const localVarAxiosArgs = await GraphsGatesApiAxiosParamCreator(configuration).updateGraph(token, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * GraphsGatesApi - factory interface
 * @export
 */
export const GraphsGatesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Delete graph
         * @param {string} token Generate token and pass it in header
         * @param {Body6} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGraph(token: string, body?: Body6, options?: any): AxiosPromise<InlineResponse2005> {
            return GraphsGatesApiFp(configuration).deleteGraph(token, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Getting File Info
         * @param {string} organisationId Organisation Id of logged in user
         * @param {string} workspaceId Workspace Id
         * @param {string} id File Id
         * @param {string} token token is passed in header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileInfo(organisationId: string, workspaceId: string, id: string, token: string, options?: any): AxiosPromise<InlineResponse2009> {
            return GraphsGatesApiFp(configuration).fileInfo(organisationId, workspaceId, id, token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Getting Canvas
         * @param {string} workspaceId Workspace Id
         * @param {string} organisationId Organisation Id
         * @param {string} fileIds File Id
         * @param {string} currentFileId File Id
         * @param {number} height Height of Graph
         * @param {number} width width of Graph
         * @param {string} paramX 
         * @param {string} paramY 
         * @param {string} selectedGate 
         * @param {string} xScale 
         * @param {string} yScale 
         * @param {string} token token is passed in header
         * @param {string} [chartType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCanvas(workspaceId: string, organisationId: string, fileIds: string, currentFileId: string, height: number, width: number, paramX: string, paramY: string, selectedGate: string, xScale: string, yScale: string, token: string, chartType?: string, options?: any): AxiosPromise<string> {
            return GraphsGatesApiFp(configuration).getCanvas(workspaceId, organisationId, fileIds, currentFileId, height, width, paramX, paramY, selectedGate, xScale, yScale, token, chartType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Getting Gates
         * @param {string} workspaceId Workspace Id
         * @param {string} token token is passed in header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGates(workspaceId: string, token: string, options?: any): AxiosPromise<Array<any>> {
            return GraphsGatesApiFp(configuration).getGates(workspaceId, token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Getting Graphs
         * @param {string} workspaceId Workspace Id
         * @param {string} organisationId Organisation Id
         * @param {string} id File Id
         * @param {number} height Height of Graph
         * @param {number} width width of Graph
         * @param {string} token token is passed in header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGraphs(workspaceId: string, organisationId: string, id: string, height: number, width: number, token: string, options?: any): AxiosPromise<Array<InlineResponse20011>> {
            return GraphsGatesApiFp(configuration).getGraphs(workspaceId, organisationId, id, height, width, token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Quad Gate
         * @param {string} organisationId organisation Id
         * @param {string} id file Id
         * @param {number} coordX 
         * @param {number} coordY 
         * @param {number} paramX 
         * @param {number} paramY 
         * @param {string} parent 
         * @param {string} yScale 
         * @param {string} xScale 
         * @param {number} width 
         * @param {number} height 
         * @param {string} token token is passed in header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quadGate(organisationId: string, id: string, coordX: number, coordY: number, paramX: number, paramY: number, parent: string, yScale: string, xScale: string, width: number, height: number, token: string, options?: any): AxiosPromise<InlineResponse20012> {
            return GraphsGatesApiFp(configuration).quadGate(organisationId, id, coordX, coordY, paramX, paramY, parent, yScale, xScale, width, height, token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Setting Gate
         * @param {string} workspaceId Workspace Id
         * @param {string} organisationId organisation Id
         * @param {string} id file Id
         * @param {string} gateNameUser 
         * @param {GatingCoords} gatingCoords 
         * @param {number} paramX 
         * @param {number} paramY 
         * @param {string} parent 
         * @param {string} yScale 
         * @param {string} xScale 
         * @param {number} width 
         * @param {number} height 
         * @param {string} token token is passed in header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setGate(workspaceId: string, organisationId: string, id: string, gateNameUser: string, gatingCoords: GatingCoords, paramX: number, paramY: number, parent: string, yScale: string, xScale: string, width: number, height: number, token: string, options?: any): AxiosPromise<Array<any>> {
            return GraphsGatesApiFp(configuration).setGate(workspaceId, organisationId, id, gateNameUser, gatingCoords, paramX, paramY, parent, yScale, xScale, width, height, token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create graph
         * @param {string} token Generate token and pass it in header
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setGraph(token: string, body?: any, options?: any): AxiosPromise<Array<any>> {
            return GraphsGatesApiFp(configuration).setGraph(token, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Getting Statistics
         * @param {string} organisationId Organisation Id of logged in user
         * @param {string} selectedGate Selected Gate
         * @param {string} id File Id
         * @param {string} token token is passed in header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statistics(organisationId: string, selectedGate: string, id: string, token: string, options?: any): AxiosPromise<InlineResponse20010> {
            return GraphsGatesApiFp(configuration).statistics(organisationId, selectedGate, id, token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update graph
         * @param {string} token Generate token and pass it in header
         * @param {Body5} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGraph(token: string, body?: Body5, options?: any): AxiosPromise<InlineResponse2005> {
            return GraphsGatesApiFp(configuration).updateGraph(token, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GraphsGatesApi - object-oriented interface
 * @export
 * @class GraphsGatesApi
 * @extends {BaseAPI}
 */
export class GraphsGatesApi extends BaseAPI {
    /**
     * 
     * @summary Delete graph
     * @param {string} token Generate token and pass it in header
     * @param {Body6} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphsGatesApi
     */
    public deleteGraph(token: string, body?: Body6, options?: any) {
        return GraphsGatesApiFp(this.configuration).deleteGraph(token, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Getting File Info
     * @param {string} organisationId Organisation Id of logged in user
     * @param {string} workspaceId Workspace Id
     * @param {string} id File Id
     * @param {string} token token is passed in header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphsGatesApi
     */
    public fileInfo(organisationId: string, workspaceId: string, id: string, token: string, options?: any) {
        return GraphsGatesApiFp(this.configuration).fileInfo(organisationId, workspaceId, id, token, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Getting Canvas
     * @param {string} workspaceId Workspace Id
     * @param {string} organisationId Organisation Id
     * @param {string} fileIds File Id
     * @param {string} currentFileId File Id
     * @param {number} height Height of Graph
     * @param {number} width width of Graph
     * @param {string} paramX 
     * @param {string} paramY 
     * @param {string} selectedGate 
     * @param {string} xScale 
     * @param {string} yScale 
     * @param {string} token token is passed in header
     * @param {string} [chartType] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphsGatesApi
     */
    public getCanvas(workspaceId: string, organisationId: string, fileIds: string, currentFileId: string, height: number, width: number, paramX: string, paramY: string, selectedGate: string, xScale: string, yScale: string, token: string, chartType?: string, options?: any) {
        return GraphsGatesApiFp(this.configuration).getCanvas(workspaceId, organisationId, fileIds, currentFileId, height, width, paramX, paramY, selectedGate, xScale, yScale, token, chartType, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Getting Gates
     * @param {string} workspaceId Workspace Id
     * @param {string} token token is passed in header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphsGatesApi
     */
    public getGates(workspaceId: string, token: string, options?: any) {
        return GraphsGatesApiFp(this.configuration).getGates(workspaceId, token, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Getting Graphs
     * @param {string} workspaceId Workspace Id
     * @param {string} organisationId Organisation Id
     * @param {string} id File Id
     * @param {number} height Height of Graph
     * @param {number} width width of Graph
     * @param {string} token token is passed in header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphsGatesApi
     */
    public getGraphs(workspaceId: string, organisationId: string, id: string, height: number, width: number, token: string, options?: any) {
        return GraphsGatesApiFp(this.configuration).getGraphs(workspaceId, organisationId, id, height, width, token, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Quad Gate
     * @param {string} organisationId organisation Id
     * @param {string} id file Id
     * @param {number} coordX 
     * @param {number} coordY 
     * @param {number} paramX 
     * @param {number} paramY 
     * @param {string} parent 
     * @param {string} yScale 
     * @param {string} xScale 
     * @param {number} width 
     * @param {number} height 
     * @param {string} token token is passed in header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphsGatesApi
     */
    public quadGate(organisationId: string, id: string, coordX: number, coordY: number, paramX: number, paramY: number, parent: string, yScale: string, xScale: string, width: number, height: number, token: string, options?: any) {
        return GraphsGatesApiFp(this.configuration).quadGate(organisationId, id, coordX, coordY, paramX, paramY, parent, yScale, xScale, width, height, token, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Setting Gate
     * @param {string} workspaceId Workspace Id
     * @param {string} organisationId organisation Id
     * @param {string} id file Id
     * @param {string} gateNameUser 
     * @param {GatingCoords} gatingCoords 
     * @param {number} paramX 
     * @param {number} paramY 
     * @param {string} parent 
     * @param {string} yScale 
     * @param {string} xScale 
     * @param {number} width 
     * @param {number} height 
     * @param {string} token token is passed in header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphsGatesApi
     */
    public setGate(workspaceId: string, organisationId: string, id: string, gateNameUser: string, gatingCoords: GatingCoords, paramX: number, paramY: number, parent: string, yScale: string, xScale: string, width: number, height: number, token: string, options?: any) {
        return GraphsGatesApiFp(this.configuration).setGate(workspaceId, organisationId, id, gateNameUser, gatingCoords, paramX, paramY, parent, yScale, xScale, width, height, token, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Create graph
     * @param {string} token Generate token and pass it in header
     * @param {any} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphsGatesApi
     */
    public setGraph(token: string, body?: any, options?: any) {
        return GraphsGatesApiFp(this.configuration).setGraph(token, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Getting Statistics
     * @param {string} organisationId Organisation Id of logged in user
     * @param {string} selectedGate Selected Gate
     * @param {string} id File Id
     * @param {string} token token is passed in header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphsGatesApi
     */
    public statistics(organisationId: string, selectedGate: string, id: string, token: string, options?: any) {
        return GraphsGatesApiFp(this.configuration).statistics(organisationId, selectedGate, id, token, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Update graph
     * @param {string} token Generate token and pass it in header
     * @param {Body5} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphsGatesApi
     */
    public updateGraph(token: string, body?: Body5, options?: any) {
        return GraphsGatesApiFp(this.configuration).updateGraph(token, body, options).then((request) => request(this.axios, this.basePath));
    }
}
